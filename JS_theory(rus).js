
<----------------КОНСПЕКТЫ ПО JAVASCRIPT()----------------->

=====================================================================================================

БАЗОВАЯ КОНЦЕПЦИЯ ООП (Объектно-ориентированное)

//Принципы ООП:

Абстракция 
/*Это отделение концепции от ее экземпляра. 
Это использование только необходимых характеристик объекта, без потери его основных свойств. 
Абстракция данных - это предоставление миру только необходимых данных, и скрытие фоновой информации.*/

Полиморфизм 
/*Это реализация задач одной и той же идеи разными способами. 
Один и тот же код может работать с разными типами данных. 
Обобщенное программирование - код, который можно применять к разным типам данных, 
не меняя его при этом. Есть языки программирования с разными типизациями.
Языки в целом бывают типизированные (Python, C, JS, Java) и нетипизированные (ассемблер)

Типизированные делятся на несколько пересекающихся категорий.
Тип типизации - на статическую типизацию, где конечные типы устанавливаются уже на 
этапе компиляции(C, C#, Java) и динамическую типизацию (JS, Python). 

Сильная/слабая - сильная не позволяет смешивать данные в одной операции, 
например вычитать из строки число (Java, Python) и слабая допускает операции 
с разными данными (C, JS).

Явная или неявная. Явная при объявлении переменной требует указывать ее тип (C++, C#), 
неявная перекладывает задачу определения типа на компилятор (JS, PHP).*/

Наследование
/*Это способность объекта или класса базироваться на другом объекте или классе. 
Это главный механизм для повторного использования кода. Наследственное отношение классов 
четко определяет их иерархию. Принято называть абстрактные прототипы классами.
Базовый класс - объект, находящийся на вершине иерархии.*/

Инкапсуляция 
/*Это размещение одного объекта или класса внутри другого для разграничения доступа к ним. 
Это ограждение какого-либо кода для ограничения доступа к нему и предотвращения его влияния
на другой код.
Пользователю предоставляется лишь интерфейс для взаимодействия с объектом. Сам же объект
он менять не может. К примеру, в JS:*/

function User (name) { //функция-конструктор объекта
	this.name = name;
	var _age = 1; //вместо того, чтобы задавать свойство, мы вводим локальную переменную
	this.displayInfo = function(){
		console.log("Имя: " + this.name + "; возраст: " + _age);
	};
	this.getAge = function() { //это Геттер. Вызвав его, можно получить переменную.
		return _age;
	}
	this.setAge = function(age) { //это сеттер, с помощью его можно менять значение _age
		if(typeof age === "number" && age >0 && age<110){ //вводим условия
			_age = age;
		} else {
			console.log("Недопустимое значение");
		}
	}
}

/*Смысл этого действа в том, что мы имеем больший контроль над свойством _age.
Мы можем выставлять любые условия для его изменения (setAge).
В этом и есть основной смысл инкапсуляции.*/

=====================================================================================================

КОНЦЕПЦИЯ ФУНКИОНАЛЬНОГО ПРОГРАММИРОВАНИЯ

/*Это другой подход к написанию кода. Условно выделяют императивное программирование и функциональное
программирование.
Функциональное программирование базируется на использовании функций. 
Мы композируем различные функции таким образом, что они образуют связную программу.
Связи между функциями осуществляются за счет одинаковых типов данных. То есть предыдущая
функция должна возвращать тот тип данных, который принимает следующая.
В ФП есть несколько правил:
1. Все функции должны быть чистыми. Т.е. при одинаковых входных переменных всегда 
выдавать один и тот же результат.
2.Все функции должны быть высшего порядка и первого класса. Для того, чтобы функция была первоклассной, 
у неё должна быть возможность быть объявленной в виде переменной.
3.Переменные неизменяемы. Создается один раз с единственным значением.
4.Все функции должны быть прозрачными. Прозрачность функции - это когда мы можем заменить ее вызов
просто значением, которое она возвращает. Если при этом состояние программы не изменилось, то функция
относительно прозрачна. То есть по сути все функции должны что-то возвращать и при этом не делать
операций, которые не отражаются в возвращаемом значении.
5. Основано на лямбда-исчислении. Это означает, что при вызове все функции подвергаются процессу
каррирования.

Если очень кратко, то смысл функционального программирования не в том, чтобы описать конкретные шаги до цели,
а в том, чтобы описать правила, следуя которым компилятор придет к нужному результату.*/

=====================================================================================================

БАЗОВЫЕ ТИПЫ ДАННЫХ В ПРОГРАММИРОВАНИИ

//«Плохие программисты думают о коде. Хорошие программисты думают 
//о структурах данных и их взаимосвязях» 
//Линус Торвальдс

//Умные структуры данных вытащат плохой код. Плохие структуры данных угробят хороший код.

/*Собственно, структуры данных нужны для их упорядочивания и хранения. Упорядоченными данными пользоваться
в разы быстрее и легче. Поэтому струтуры данных - одна из самых важных областей программирования.
Правильно структурированные данные - залог быстрого и эффективного приложения, которое можно легко 
масштабировать.

Бывают линейные (когда обход данных последователен) и нелинейные.

//===========================================
Массив - это структура, упорядоченно хранящая данные и идентифицирующая их по индексу.
Иногда называют таблицей. Бывают одномерные и многомерные. Самая простая и известная структура.

//===========================================
Стек - это как бы банка чипсов Лэйс. Данные хранятся в ней так, что мы имеем доустп лишь к самому верхнему.
Соответственно, извлечь можем тоже лишь его. Если мы хотим добавить новый элемент, то 
он будет добавлен как самый верхний. И никак иначе. Именно так работает принцип LIFO 
(Последним пришел — первым вышел).

//===========================================
Очередь - это как та же самая банка Лэйс, но без дна. Тут работает принцип FIFO (Первым пришел — первым вышел).
То есть извлекая из очереди элементы мы будем брать сначала тот, который в самом низу (попал в нее первым).
Тут все довольно наглядно и очень похоже на обычную очередь в кассу. 
Нет методов, позволяющих что-то вставить в середину очереди. У ней есть только первый и последний индексы,
а  все, что между ними, как бы инкапсулировано.

//===========================================
Связный список - это структура данных, состоящая из узлов. Каждый узел содержит данные, а также ссылки
на соседние узлы. Бывают однонаправленными и двунаправленными (когда ссылки в обе стороны).
По сути элемент связного списка - это контейнер, который содержит два поля - адрес и данные. Адрес
содержит указание на соседей. Если соседа нет - то значение null.
Если массив занимает непрерывную область памяти, то связный список не обязательно.Узлы могут быть
в разных местах памяти, так как к ним можно просто получить доступ по ссылке.
Пример связного списка в JS:
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
}

//===========================================
Граф - это множество узлов, соединенных друг с другом в виде сети. Эти соединения называются ребрами.
Собственно граф это коллекция вершин плюс набор ребер(представленных в парах вершин). Например:
G = {V, E} //сам граф
V = {0, 1, 2, 3} //V - это вершины графа
E = {(0,1), (0,2), (0,3), (1,2)} //набор ребер.
Есть неориентированный граф (у ребер нет направления) и ориентированный граф (у ребер есть направление).

//===========================================
Деревья
Самый распространенные - двоичное дерево, двоичное дерево поиска. 
Дерево - это иерархическая структура данных. В дереве не бывает циклов. По факту дерево - это
ациклический граф.
Базовая терминология - корень, предок/потомок, лист(крайний элемент), соседний элемент, поддерево.
Бинарное дерево - каждый элемент (кроме листьев) связан с двумя поддеревьями. ТО есть они являются его
потомками.
Бинарное дерево поиска - это особый вариант двоичного дерева. Они имеет схожую структуру, но его узлы
расположены в соответствии с определенной логикой: любое значение меньше узла становится левым ребенком,
любое значение больше узла становится правым ребенком. Этот вид используется собственно для двоичного
поиска элемента в словаре.

//===========================================
Бор - это особый вид дерева, позволяющий хранить ассоциативный массив, ключами которого являются строки.
Иначе называется префиксное дерево.
В каждой вершине хранится также числовое значение, обозначающее, сколько строк заканчиваются в этой вершине. 
Строки представляются в виде путей по бору от корня (пустой строки) до последнего символа.

//===========================================
Хеш-таблица. Это структура данных, где данные разбиты на пары "ключ-значение". Хеширование — это процесс,
применяемый для уникальной идентификации объектов и сохранения каждого объекта по заранее вычисленному индексу, 
именуемому его «ключом». Таким образом, объект хранится в виде «ключ-значение», 
а коллекция таких объектов называется «словарь». Тип данных Object в JS как раз по сути является словарем.
Кстати говоря, Object лучше использовать для поиска, чем массив, так как поиск по нему осуществляется
за O(1), т.е. за одну операцию. В то время как массив приходится перебирать, пока не найдется значение.*/


=====================================================================================================

ОСНОВЫ JS

Типы данных в языке
/*В JS есть пять общих типов данных:

number - это число, цлое или дробное.
В отдельную категорию вынесены большие числа. Это тип bigInt.
Они выглядят как const bigInt = 1234567890123456789012345678901234567890n.
Собственно, буква n в конце - это отличие.
Также распространена "scientific notation" для записи чисел с большим количеством нулей. 1000 = 10e3*/
//Методы преобразования в число в JS
//Эти методы удаляют из строки все символы, которые не могут быть преобразованы в число.
//А parseInt удаляет еще и все знаки после запятой
parseInt('8.2a', [base]) //8, base - основание системы счисления
parseFloat('2.5a') //2.5

Number('5') //объект-обертка, позволяющий работать с числами. У него есть свои методы.
//Его особенноть в том, что он при наличии лишних символов выдает ошибку.
//В целом это преимущество, так что данный метод приоритетен. Он частично фиксит безтиповость JS.

num.toFixed(x) //вернет строку, округленную до x знаков после запятой
num.toPrecision(x) //возвращает строку с x значимых чисел, например:
5.123456.toPrecision(2) = 5.1


/*string. В некоторых языках есть специальный тип данных для одного символа, char,
но в JS такого нет.


boolean - логический тип*/
false == '', 0, null, undefined, false, NaN.
true == [], {}, function.


/*null - пустое значение. Используется для записи путого или неизвестного значения.*/


/*undefined - неопределенное значение. Его возвращают все
функции, для которых не задано иное (return).

У примитивных типов данных нет свойств и методов. Тем не менее, JS позволяет 
рабоать с ними, как с объектами, например string.toUpperCase(). Это происходит
благодаря тому, что у всех примитивов, кроме null и undefined есть объект-обертка.
Т.е. примитив временно преобразуется в объект, выполняется операция, затем временный 
объект удаляется.*/


Object
/*И отдельный тип Object.
Первые пять типов называют примитивами. 
Объект - это более сложноорганизованный тип данных. У него есть подтипы:
массив, функция, регулярное выражение.*/

/*Помимо этого, есть symbol. Symbol - уникальное значение*/
let id = Symbol();
let id = Symbol("id"); //Символ с описанием
//Описание это просто текст. Два символа с одинаковым описанием не равны.

typeof ()
/*С помощью typeof можно узнать тип аргумента.
typeof возвращает строку с названием типа данных.

Существует забавный баг, что typeof null === object, хотя null это по сути примитив.
Но этот баг живет в JS уже давно, и вряд ли будет исправлен.*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Операторы

Равенство
== != //пытаются выполнить преведение типов
=== !== //не делают преведение типов

!! (Bang Bang) //!!number преобразует в логическое значение.

?? (nullable)
/*Это новая разработка.
Дело в том, что при проверке некоего значения на true ли false,
'', false, 0 - дают ложь, хотя иногда это могут быть нужные нам значения.
Поэтому рекомендуется проверять значение на value !== null && value !== undefined,
чтобы не исключать '', false и 0.
?? помогает сделать это:
Обычно в тернарном выражении ? означет проверку value на true/false.*/
value ? first : second
//теперь же проверим value на value !== null && value !== undefined.
value ?? first : second
//Одним словом, этот оператор пропускает ложные значение, но не пропускает
//null и undefined.

?. (optional chaining)
//Позволяет отлавливать ошибки в цепочках и возвращать undefined, если
//последующая конструкция или значение равняется null или undefined.
//При использовании обычной точки удет выброшена ошибка.
value?.value2 //если value2 не определено, то получим undefined(который можно привести к false)

//Пример:
var user = {
	name: 'Alex',
	age: 25,
	contacts: {}
}

function readMobile (user) {
	(user.contacts.telephone.mobile)
	? console.log('mobile exists')
	: console.log('no mobile')
}
readMobile(user)
//Выдаст ошибку, так как user.contacts.telephone не существует

function readMobile (user) {
	(user.contacts?.telephone?.mobile)
	? console.log('mobile exists')
	: console.log('no mobile')
}
readMobile(user)
//Выдаст undefined, который сконвертируется в false, сработает второе условие 'no mobile'.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Деструктирующее присваивание
/*Destructuring assignment - применяется при работе с массивами, объектами и 
сложными функциями, которые имеют много параметров. Это специальный синтаксис,
который позволяет распаковывать объекты, массивы и любые итерируемые объекты
в наборы переменных.

Несмотря на название, разрушение здесь не происходит. Исходный объект не имзменяется.
Происходит лишь присваивание переменных.


:====================Работа с массивом::====================*/
let [var1, var2] = [1, 2, 3, 4, 5] //var1 = 1, var2 = 2

const [var1, , , var2] = [1, 2, 3, 4, 5] //var1 = 1, var2 = 4

let [var1, var2, var3] = [1, 2] //var1 = 1, var2 = 2, var3 = undefined

let [var1, var2, var3 = 10] = [1, 2] //var1 = 1, var2 = 2, var3 = 10

//Значение по умолчанию не работает, когда для него находится значение:
let [var1, var2 = 10, var3] = [1, 2, 3, 4, 5] //var1 = 1, var2 = 2, var3 = 3

let [var1, var2, ...rest] = [1, 2, 3, 4, 5] //var1 = 1, var2 = 2, rest = [3, 4, 5]

//Значения по умолчанию могут быть сложными типами данных:
let [var1, var2, var3 = prompt('name?')] = [1, 2] //var1 = 1, var2 = 2, var3 = calling prompt

//главное, чтобы правая часть возвращала итерируемый объект
let [var1, var2] = 'I_am_Superman'.split('_') //var1 = 'I, var2 = 'am'

//Поменять местами значения двух переменных (мини-хак) 
[a, b] = [b, a]



//===================Работа с объектами:====================
let {title, height} = { title: "Menu", height: 200} //title = 'Menu', height = 200

//Важно имя переменной, а не порядок.
let {height, title} = { title: "Menu", height: 200} //height = 200, title = 'Menu'

//Если нужно другое имя, то оно присваивается дополнительно:
let {height: h, title: t} = { title: "Menu", height: 200} //h = 200, t = 'Menu'

let {title, height, width = 100} = { title: "Menu", height: 200}
//title = 'Menu', height = 200, width = 100

//Опять же, важно имя переменной, а не порядок:
let {width = 100, title, height} = { title: "Menu", height: 200}
//title = 'Menu', height = 200, width = 100

let {title, ...rest} = { title: "Menu", height: 200, width: 100}
//title = 'Menu', rest = {height: 200, width: 100}

//При вложенных свойствах:
let {title, params: {height} } = { title: "Menu", params: {height: 200} } 
//title = 'Menu', height = 200


//===================Применение в функции:====================
let obj = {
	name: 'Uriy',
	surname: 'Korotovskikh',
	someOtherProp: 'anyValue'
}

//Нужно передать объект в функцию и использовать там только два его свойства.
//Не имеет смысла работать со всем объектом и в функции использовать obj.name, obj.surname.
//Вместо этого используем деструктуризацию. Такой метод можно часто встреить в React.
//Можно совершить любые операции со свойствами - дефолтное значение, новое название 
//переменной и так далее.
function getFullName ({name:firstName = 'noName', surname:secondName = 'noSurname'}) {
	console.log(`Full name is ${firstName}, ${secondName}`)
}

getFullName(obj) //просто передаем объект в функцию.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Переменные let, var, const
/*let, const - это переменные локальные, только для функции или цикла. 
var существует и до объявления(во всем коде). Но ее значение до объявления будет undefined. 
let существует только после объявления. 
var влияет на всю область видимости (либо весь код, либо функция). 
let объявленая в функции видна только в функции(а также внутри внутренних элементов функции). 
var в функции влияет на вар глобально.

Var, объявленная в глобальной области видимости, записывается в свойства window*/

let, var и const в циклах. 
/*Var - видима из любого участка кода. Но опредлена лишь после своего определения. 
Для цикла var одна, она просто меняется для каждой итерации. 

Let живет только в квадратных скобках, в которых была определена. 
Для каждой итеарции она своя, глобально при этом ее вообще нет. 
Это легко решает проблему замыкания функций в циклах 
(в каждом цикле у каждой функции будет своя переменная). 
С var так не получится, так как в итоге она будет общей для всех итераций. 
Const ведет себя так же как let в цикле.*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Циклы

for (let key of item)
/*Обычно этот цикл используется для перебора элементов в массиве.
Можно работать со строкой, перебирая все ее элементы, да и вообще
с любыми итерируемыми объектами.

Цикл for of работает с символами. Если у объекта есть символ Symbol.iterator в
прототипе, то данный цикл может работать с ним.*/
for (let k of 'Hello') { console.log(k) }

/*for of работает только с итерируемыми объектами. Когда цикл запускается он один раз
вызывает метод Symbol.iterator. Если такого метода нет - вернется ошибка.
Этот метод должен вернуть итератор - объект с методом next()
Итератор возвращает объект типа {done: Boolean, value: any}, когда done 
становится true, цикл заканчивается.
У самого итерируемого объекта нет метода next().

Для лучшего понимания, реализуем перебор строки при помощи for of вручную*/
let str = 'Hello'
let iterator = str[Symbol.iterator]()

while (true) {
	let result = iterator.next()
	if (result.done) break
	console.log(result.value)
}

//======================================================

for (key in object)
/*Используется для перебора ключей или свойств объекта.
Ключи выдаются в порядке создания, за исключением целочисленных - они
сортируются по возрастанию. Целочисленный ключ - это строка, которая может
быть преобразована в число.*/

for (let key in obj) { 
	console.log(key) //показать ключ
	console.log(obj[key]) //показать значение
}

//======================================================

switch () {case ...}
/*Вообще это не цикл. Но... Это очень похожая по функционалу конструкция,
поэтому я решил, что место ей здесь. 

Данная конструкция принимает в себя любое выражение и выводит результат, когда
срабатыввает соответствующее условие (case).
Есть default - этот случай сработает, если не сработал ни один из кейсов. 
Стоит учитывать, что сравнение строгое, значит тип данных тоже должен совпадать,
чтобы кейс сработал.

Желательно после каждого кейса использовать break, иначе, если кейс сработает,
и там не будет break, то выполнение пойдет дальше и будут выполнены все последующие кейсы,
включая default. 

Пример:*/
let a = 2
let b = 2
switch (a * b) {
	case 1: 
		console.log(1)
		break

	case 2: //допустимо группировать условия
	case 3:
		console.log(23)
		break

	case '4': //не выполнится, так как не совпадает тип данных
		console.log('Number 4')
		break

	case 4: //выполнится
		console.log(4)
		break 

	default: console.log('Nothing done.') //если не сработает ни одно условие
}

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Math

//Это встроенный объект в JavaScript. Основные функции:
Math.random() //Генерирует случайное число от 0(включая) до 1(не включая)
Math.max(x, y, ...) //Возвращает большее из чисел. В аргументы могут быть переданы тоько числа
Math.min(x, y, ...) //Возвращает меньшее из чисел. В аргументы могут быть переданы тоько числа
Math.pow(x) //Взводит число в степень
Math.floor(x) //Округляет число в меньшую сторону, убирая все цифры после запятой
Math.ceil(x) //Округляет число в большую сторону, убирая все значения после запятой
Math.trunc(x) //Просто удаляет все числа после запятой
Math.round(x) //Округляет число до целого. Если дробная часть меньше 0.5, то к меньшему, в ином случае
//наоборот
Math.abs(x) //возвращает абсолютное значение числа

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Date

//Также встроенный объект в JavaScript.

let date = new Date()//создаст объект даты с текущим временем
let date = new Date(100000)//если передать в аргумент число, то это создаст объект даты с отсчетом в мс от 
//1 января 1970 года (создание UNIX-истем). Это называется timestamp (из него легко получить дату).
let date = new Date("2021-02-26")//Если в аргумент передана строка, то из нее "считывается" дата.
let date = new Date(2011, 0, 1, 2, 3, 4, 567)//Можно задать и так, где числа в порядке: год, месяц (от 0 до 11),
//день, час, минута, секунда, милисекунда.

//Чтобы получить год/месяц и.т.д. из даты есть методы объекта:
getFullYear()
getMonth()
getHours()
getDay() //возвращает день недели (0-воскресение, 6-суббота)
getTime() //возвращает timestamp – количество миллисекунд, прошедших с 1 января 1970 года UTC+0

//Для задания/изменения параметров даты есть методы
setFullYear()
setMonth()

//В объекте Date присутствует автоисправление, то есть, если мы добавим к ней 70 секунд, то автоматически
//будет установлена следующая минута.
let date = new Date();
date.setSeconds(date.getSeconds() + 70) //+ 1 минута и 10 секунд

//Чтобы измерить разницу во времени, надо преобразовать дату в число(как было указано выше это будет timestamp).
//Даты в таком формате можно складывать и вычитать, таким образом измеряя время.

Date.now() //специальный метод, который позволяет получать текущую дату. Его результат аналогичен
//new Date().getTime(), но метод Date.now() гораздо быстрее, так как не создает объекта даты.
//Акутально, например, в играх на JS.

Date.parse(str) //Считывает дату из строки. Строка должна быть определенного формата YYYY-MM-DDTHH:mm:ss.sssZ.
//Здесь Z обозначает часовой пояс. Если хотим указать его, то заменяем Z на +-hh:mm. 
//T обозначает разделитель. Пример:
Date.parse('2012-01-26T13:51:50.000-07:00')
//Часто можно встретить, когда мы передаем дату через JSON. Так как он не поддерживает дату, то после
//конвертации необходимо отдельно сделать из строк даты при помощи Date.parse().


>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

localStorage, sessionStorage

/*Объект storage - это встроенное в браузере хранилище. Свойства localStorage и
sessionStorage позволяют ссылаться на этот объект. Это свойства window.*/
window.localStorage
window.sessionStorage
/*Разница в том, что localStorage хранит данные даже после перезапуска браузера и ОС. 
sessionStorage хранит данные, пока открыта вкладка, неважно, сколько раз она была перезапущена.
Но получить к ней доступ можно только в этой же вкладке.

localStorage одна на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
Соответственно, к ней можно получить доступ из любой вкладки, если она имеет
такой же домен. Например, с любой страницы одного и того же сайта.

Вообще, по localStorage вердикт такой:
У нее есть свои плюсы, например то, что она полностью на стороне клиента, и нет нужды
передавать данные на сервер (как в куках). 
Достаточный объем (до 5MB). 
Но все дело в том, что это синхронное API (Application programming interface), в связи с чем 
не рекомендуется хранить там серьезные данные, которые могут заморозить работу всего сайта,
пока будет извлекаться/передаваться в localStorage. Пока браузер работает с ней, весь другой код
будет ждать.

В связи с этим, рекомендуется вообще не использовать его в продакшене. Либо использовать 
для хранения минимального объема данных.
Вместо localStorage есть много более сложных, зато лишенных недостатков синхронности API,
например: indexedDb.

Тем не менее, иногда localStorage может быть полезен, поэтому основы стоит знать.
Это API работает только со строками, так что все данные будут преобразованы в них.
Данные хранятся в формате ключ-значение (key: value).*/
const num = 143

localStorage.setItem('number', num) //поместить в память.
//преобразует 143 в строку автоматически, тк работает лишь со строками.
localStorage.setItem('number', num.toString()) //более корректно.

localStorage.getItem('number') //получить объект из памяти

ocalStorage.removeItem('number') //удалить ключ из памяти и его значение
localStorage.(clear) //очистить все.

localStorage.setItem('objPerson', JSON.stringify(obj)) //сохранить в память объект

//получить объект из памяти
let raw = localStorage.getItem('objPerson')
let person = JSON.parse(raw)


//==============================
События localStorage

window.addEventListener('storage', event => {
	console.log(event)
})
//или
window.onstorage = (event) => console.log(event)

//При срабатывании генерируется событие StorageEvent, которое обладает след.свойствами:
key// ключ, который обновился (null, если вызван .clear()).
oldValue// старое значение (null, если ключ добавлен впервые).
newValue// новое значение (null, если ключ был удалён).
url// url документа, где произошло обновление.
storageArea// объект localStorage или sessionStorage, где произошло обновление.

//Особенность этих событий в том, что они срабатывают на всех вкладках (объектах window), 
//где есть слушатели событий, кроме той, на которой оно непосредственно произошло.
//Это применяется, например, для синхронизирования информации с разных вкладок одного источника.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

console API

/*Console API обеспечивает функциональность, которая позволяет разработчикам 
выполнять задачи по отладке, такие как логгирование сообщений или значений переменных 
в определённых местах кода, измерение времени, требуемое на выполнение задачи.

Основные команды, которые могут пригодиться в разработке.*/
console.log(obj) //простой вывод в консоль

console.error(err) //вывод ошибки в консоль

console.assert(value) //выводит сообщение об ошибке, если утверждение (value) ложно
//в случае, если оно истинно, не выводит ничего.

console.clear() //очищает консоль

console.time(timerName) //запускает таймер с указанным именем (нужно передать строку с именем таймера).

console.timeEnd(timerName) //останавливает таймер с указаным именем и выдает его значение.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

ФИШКИ И СОКРАЩЕНИЯ JS

//Одновременное объявление переменных
let x, y, z
let x, y, z = 0 //undefined, undefined, 0

//Множественное объявление переменных
let [x, y, z] = [1, 2, 3]

//Тернарник
Condition ? case1 : case2
//Также применим для определения переменной в зависимости от условия:
let variable = (20 > x) ? 'base value' : 'alternative value'

//Значение по умолчанию (фолбэк)
let imagePath = getImagePath() || 'default.jpg'

//Быстрая проверка для запуска функции
//вместо
if (isLoggedIn) { goToHomepage() }
//используем
isLoggedIn && goToHomepage()

//Смена значения
[x, y] = [y, x]

//Проверка нескольких условий
//вместо
if (value === 1 || value === 'one' || value === 2) { ... }
//используем
if ([1, 'one', 2].includes(value)) { ... }

//Преобразование строки в число
let num = +'string'

//Замена метода Math.floor() побитовым сдвигом
Math.floor(5.5) == ~~5.5

//Копирование одноуровневого объекта (без вложений и свойств-объектов) 
//при помощи оператора расширения
const cloneObj = {...obj}


=====================================================================================================

СТРОКИ String, РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ RegExp

String
/*В JS любые текстовые данные являются строкой. Нет спеицального типа данных
для одиночного символа.
Строки неизменяемы, их можно только перезаписывать.
Строки заключаются в кавычки. JS поддерживает кавычки трех типов.

Преимущество самых новых обратных кавычек `` в том, что они поддерживают
использование переменных в тексте ${variable}, а также позволяют записывать
текст в несколько строк (поддерживают перенос строки).

В обычных кавычках перенос строки достигается при помощи*/
'\n'

//Также есть много других специальных символов:
'\t' //абзацный отступ
'\'' '\"'//кавычки
'\xXX' //Символ с шестнадцатеричным юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.
'\uXXXX' //Символ с шестнадцатеричным кодом XXXX, например, \u00A9 — знак копирайта ©
'\u{X…XXXXXX}' //Символ с длинным кодом(суррогатная пара), например, смайл.

//Суррогатная пара - когда для записи символа недостаточно одного 16-и битного слова.
//Применяется комбинация двух слов. Из-за этого есть небольшие проблемы в
//работе с такими символами в JS.

//Все троки имеют свойство length
String.length

//Иногда со строками можно работать как с массивами символов.
//Например, получить значение символа на позиции.
String[2] //'r'
//Еще есть устаревший метод
charAt()
//Строку можно перебрать при помощи цикла for of


Экранирование символов
/*В JS есть специальные символы, сами по себе содержащие смысловую нагрузку в коде.
Это, например, '.'
Чтобы программа не пыталась интерпретировать их, а работала с ними как с обычными символами,
используется обратный слэш*/

(/\./) //регулярное выражение, где точка - это просто символ точка.
//Вот полный перечень символов, которые бывает нужно экранировать
[ \ ^ $ . | ? * + ( ) / ]

Сравнение строк
/*При сравнении строк нужно учитывать что нижний регистр считается больше.
Буквы, имеющие диактретические знаки, такие как Ö, идут не по порядку.

Все происходит потому, что JS сравнивает символы по их коду.
Больше код - больше символ.
Таблица символов в юникоде:*/
'ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~'
'¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ'

//Для сравнения слов из разных языков корректно использовать:
String.localeCompare(str2)


Юникод
/*Юникод - это стандарт кодирования символов.

До него существовал ASCII.
В этой системе было всего 128 вариантов кода для кодироваия символов.
Позже ее расширили до восьмибитной и символов стало 256, что тоже не много.
Первая половина была занята под латинские символы и самые распространенные знаки,
другую обычно использовали для национальных алфавитов.
В юникоде началальные значения сохранены, так что он поддерживает ASCII.

Юникод был предложен в 1991 году. 
Он состоит из набора символов(USC) и семейства кодировок(UTF).

Он включает в себя практически все языки мира. 
Кодовое пространсто в нем разбито на 17 плоскостей по ~65 тысяч символов.
Нулевая плоскость является баовой и содержит данные основных письменностей.
Остальные предназначены для старых иероглифов и редких языков, а также для 
индивидуального кодирования.

Для обозначения символов Unicode используется запись вида 
«U+xxxx» (для кодов 0…FFFF), или «U+xxxxx» (для кодов 10000…FFFFF), 
или «U+xxxxxx» (для кодов 100000…10FFFF), где xxx — шестнадцатеричные цифры.

Например: U+040F.*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Методы строки

String.toLowerCase(), toUpperCase()
/*Преобразуют строку в новый регистр.
Возвращает новую строку, изначальная строка не изменяется.*/

-----------------

String.trim()
/*Удаляет пробелы с обоих концов целевой строки.
Для удаления только с одной стороны используется trimLeft() и trimRight()
Возвращает новую строку, старая строка не изменяется.*/

-----------------

String.indexOf(searchValue, [fromIndex])
/*Ищет первый элемент со значением searchValue в строке.
Возвращает индекс найденного элемента.
Если найти не удалось, возвращает -1.
Метод РЕГИСТРОЗАВИСИМЫЙ.
Строка при этом не изменяется.

fromIndex - необязательный параметр, который определяет, с какого индекса
начинать поиск.
*/

----------------

String.lastIndexOf(searchValue, [fromIndex])
/*Возвращает индекс последнего элемента в строке, удовлетворяющего условию.
При заданном fromIndex ищет последний элемент до fromIndex.*/

----------------

String.includes(searchValue, [position])
/*Определяет, содержит ли строка заданную подстроку. Возвращает true/false.
При заданном position будет искать, начиная от этой позиции.
Метод РЕГИСТРОЗАВИСИМЫЙ.
Сама строка не изменяется.

Для поиска на первой и последней позиции есть startsWith() и endsWith()*/

----------------

String.slice(start, [end])
/*Метод возвращает новую строку, вырезая ее из старой.
Метод не меняет старую строку.

Новая строка формируется из символов от start и до end(если он указан).
Причем символ с индексом end уже не включается.
Если он не указан - вернется строка от start и до конца.

Метод поддерживает отрицательные параметры. В этом случае программа
будет перебирать строку справа налево.*/
str = 'Uriy Korotovskikh'
str.slice(-9, -5) //'otov'

----------------

String.split([separator, [limit]])
/*Возвращает массив из строк, на которые разбивается исходная строка,
при этом separator(по которому происходит разбитие строки) удаляется.
Если separator не был назначен, то вся строка попадет в массив как один элемент.
Сама строка при этом не изменяется.

limit - необзятаельный параметр. Он ограничивает количество подстрок, которые могут быть
включены в массив. Если их число больше - они просто обрезаются.

Возвращает массив.*/

----------------

String.codePointAt(pos)
/*Возвращает код (юникод) символа на позиции pos.*/

----------------

String.fromCodePoint(code)
/*Создает символ по его коду. Допускается как обычная запись:*/
String.fromCodePoint(90) //'Z'
//Также и через шестнадцатиричный код
String.fromCodePoint(0x005a)

----------------

String.localeCompare(str2, [locales, [options]])
/*Метод предназначен для сравнения двух строк на разных языках.
По умолчанию используется язык из окружения.

Необязательные параметры позволяют выбирать язык и настраивать поведение 
функции сортировки (чувствительность сортировки итп). Пример с locales:*/
'ä'.localeCompare('z', 'de') // отрицательное значение: в немецком буква ä идёт рядом с буквой a
'ä'.localeCompare('z', 'sv') // положительное значение: в шведском буква ä следует после буквы z

/*Возвращает отрициательное число, если str < str2
Возвращает положительное, если str > str2
Возвращает 0, если str = str2

Например, обычное сравнение покажет, что 'Ös' > 'Ws'
Сравнение localeCompare укажет обратное.*/

----------------

String.substring(indexA, [indexB])
/*Возвращает подстроку строки между двумя индексами.
От indexA и до (не включая) indexB.
Если indexB опущен, то будут извлечены символы до конца строки.
Если любой из аргументов больше, чем String.length, то он будет приравнен к String.length.

Если indexB больше, чем indexA, то метод сработает так, будто бы они поменены местами.*/

----------------

String.repeat(count)
/*Конструирует и возвращает новую строку, 
содержащую указанное количество соединённых вместе копий строки (count), 
на которой он был вызван.

Старая строка не изменяется.*/

----------------

String.padStart(length, [string])
/*Возвращает новую строку. 
length - то, какой длины должна быть новая строка, соответственно метод добавит (length - текущая длинна)
символов, которые мы указываем вторым параметром (string).

Если параметр string опущен, то добавится нужное число пробелов.
Если параметр string слишком большой, чтобы войти в новую length, то он будет обрезан.

Если параметр length меньше текущей длины, то ничего не изменится.

Старая строка не изменяется.

Метод padEnd() работает аналогично, но добавляет символы в конец строки.*/

----------------

String.replace(regexp|substring, newSubstr|function)
/*Возвращает новую строку с замененной частью.
regexp - регулярное выражение для поиска в строке заменяемых фрагментов.
substring - фрагмент строки, который нужно заменить (заменяется лишь первое вхождение).
newSubstr - заменяющая строка.
function - функция для создания новой подстроки.

Интересный момент - в newSubstr можно передавать специальные параметры замены:
$1 - первая из совпавших строк, $2 - вторая из них, $n - n-нная из них.
Таким образом легко переставить символы или субстроки местами.

Старая строка не изменяется.*/

----------------

String.match(regexp)
/*Возвращает массив с результатами сопоставления, то есть теми занчениями, которые удовлетворяют
регулярному выражению. Если их нет, то вернет null.
В параметр можно передавать лишь регулярные выражения.

Старая строка не изменяется.
*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

RegExp Регулярные выражения
/*Это специальный инструмент для поиска или замены строк. По природе это встроенный класс.
Есть два синтаксиса для их задания:*/
let regexp = new RegExp('template', 'flags') //длинный
let regexp = /template/gi

//Основные флаги
g //включает поиска всех совпадений, а не только первого
i //включает игнорирование регистра
m //включает multiline режим, когда $ и ^ работают не только для начала и конца текствого фрагмента,
//но и для начала и конца каждой строки внутри него

//Используется, например, в поиске в строке (метод match)
str.match(/ab/gi)
//Если совпадений нет - то вернется null

//Также используется в замене в строке
str.replace(/ab/gi, replacement)

----------------

Синтаксис RegExp
/*
. любой одиночный символ
[ n ] любой из них, диапазоны от и до (включая) [a - c]
n$ конец строки, без символа n просто выбирает конец всех строк
^n начало строки, без символа n просто выбирает начало всех строк
\ экранирование
\d любую цифру
\D все что угодно, кроме цифр
\s пробелы
\S все кроме пробелов
\w цифробуквенный символ (включая _) Warning! Не работает с кириллицей
\W все кроме цифробуквенных символов
\b граница слова
\B не граница
() группировка, например, (\s|-) - пробел или дефис

//Квантификация
n{4} искать количество символов n подряд 4 раза
n{4,6} искать количество символов n от 4 до 6
n* количество символов от нуля и выше
n+ количество символов от 1 и выше (не включая)
n? количество символов нуль или 1 раз
*/

//Пример RegExp для проверки валидности емэйла
let regexp = /\S\w+@\w+.\w+/

=====================================================================================================

DOM и работа с элементами

Структура

window
/*В каждой вкладке браузера свой объект window. Это глобальный объект.
Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. 
По умолчанию это те, что встроены в язык или среду исполнения.

В браузере он называется window, в Node.js — global, в другой среде исполнения может называться иначе.
document - это часть window.*/
window.document.getElementById("header")

//У объекта window много методов.
window.innerHeight //узнать высоту области содержимого окна браузера, включая, горизонтальный скроллбар
window.innerWidth //узнать ширину области содержимого окна браузера, включая, вертикальный скроллбар


//===============================
document
/*Каждая веб-страница, которая загружается в браузер, имеет свой собственный объект document.
Он служит началом для DOM-модели.
Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. 
Из него мы можем получить доступ к любому узлу.*/


//===============================
DOM (document object model)
/*В соответствии с этой моделью, каждый элемент страницы является объектом.
Каждый элемент задается определенным тегом. Все теги заключены в структуру дерево данных.
Таким образом, каждый узел этого дерева - объект. Корневой элемент дерева - html.
Все элементы дерева находятся в document.

html, body, head - должны быть обязательно.

Все, что есть в HTML, даже комментарии, является частью DOM.
Текст формирует текстовые узлы, у них не может быть потомков.*/


//===============================
BOM (browser object model)
/*Это набор дополнительных объектов, предоставляемых браузером. Их нет в докуменете, но они есть в window.
Самые нужные из них navigator и location*/

-------------------------------------

Присовение элементов в переменные
/*Одним из основных моментов при работе с сайтом является обращение к его элементам.
Это делается при помощи простых команд:*/

getElementsByID()
getElementsByClassName()
getElementsByTagName()
querySelector() //наиболее универсальный, можнов стваить что угодно, выберет 1 элемент.
querySelectorAll()// возвартит NodeList(почти массив) из всех подходящих


HTMLCollection. и NodeList.
/*Выше указанные методы возвращают HTMLCollection или NodeList.
getElementsBy возвращает HTMLCollection.
querySelectorAll возвращает NodeList

Обе эти структуры - массивоподобные. Они имеют свойство length и индексы.


HTMLCollection имеет следующие встроенные методы:
.item(index) - возвращает элемент под указаным индексом
.length - возвращет число элементов
.namedItem('itemID') - возвращает элемент из коллекции по айди(также работает
HTMLCollection['itemID'])
HTMLCollection[x] - просто возвращает по x номеру элемент

главная особенность HTMLCollection - она динамическая. То есть, если в дальнейшем
какому-либо элементу будет присовен такой же класс, либо создан элемент с таким же tagName,
то он будет сразу же добавлен в эту коллекцию.

NodeList - почти то же самое, что и HTMLCollection. Но он статический, что означает,
что он не будет изменяться при появлении новых или удалении старых элементов.

Стоит помнить, что это array-like, так что методы массива для них не работают.
Но можно перебирать как массив при помощи for of*/


//Последовательный поиск (тип элемента в элемента класса .class)
querySelector(.class a) //Данная команда найдет все тэги "a" в элементе с классом .class
querySelector(.class a).getAttribute('id')// так мы можем получить аттрибут элемента.
querySelector(.class a).setAttribute("attribute", new value)// поменять значение аттрибута
querySelector(.class a).setAttribute("href", 'https/...')// меняет значение ссылки.

//Универсальная команда для смены какого-либо аттрибута у элемента HTML
element.setAttribute('name', 'value')
//Можно использовать комбинацию для получения аттриута
getElementsById("myBtn").getAttribute("onclick")


//=====================Data-аттрибуты:======================
//Можно задать пользовательский аттрибут
element.setAttribute("data-number", "90")
//Его можно использовать как вспомогательное значение-идентификатор элемента
//Любой атрибут, чьё имя начинается с data-, является data-* атрибутом.
//Это очень удобно для присвоения индексов набору элементов, а также в CSS можно выборочно
//давать стили по этим аттрибутам: div[data-columns='4'] { width: 600px;}
//К data-* атрибутам легко получить доступ через объект dataset.

//=====================Работа с классами:======================
let element = querySelector(...)
element.classList.add('new class');
element.classList.add('first class', 'second class');// добавляет сразу несколько классов
element.classList.remove('new class');
element.classList.toggle('class');
//toggle - переключатель, добавляет класс, если его нет, и убирает, если он есть.
element.classList.contains('class') //проверяет наличие класса у элемента.

elem.innerHTML// меняет внутри элемента структуру, вычисляется как HTML, работает дольше
elem.textContent// меняет только текст внутри элемента, работает лишь для текста, не тегов.
elem.firstChild.nodeValue// то же, что и текст-контент.

form.onsubmit = function()// интересное для работы с формами. 
//Хоть сабмит это отдельная кнопка, но подключаем мы функцию к самой форме.

evt и preventDefault()
//evt - сокращенно event. Это невидимый объект, когторый JS создает при запуске события. 
//У него есть свои методы, 
//например preventDefault() - отменяет стандартное действие события. К примеру:

form.onsubmit = function(evt) {
	evt.preventDefault()
	console.log('Форма не отправлена!')
//Выведет строку в консоль вместо действия отправки данных формы.

----------------------------------

//Создание элемента, css
let p = document.createElement('p')
p.classList.add('myClass') //добавим класс
p.textContent('Hello!') //добавим текст в абзац

//Вставим этот элемент в станицу (вставляется в конец указанного элемента (внутри))
document.body.appendChild(p)

//Теперь вставим после элемента (не внутри)
document.body.insertBefore(p, element) //вставит наш абзац после element(который надо предварительно 
//получить, либо прямо здесь document.body.insertBefore(p, document.querySelector('#id')))

//Удалим элемент p, являющийся дочкой elem
document.elem.removeChild(p)

//Замена элемента sp1 на sp2, являющихся дочками parentDiv
let parentDiv = querySelector('#id') //Выбираем родительский элемент
parentDiv.replaceChild(sp2, sp1)

//В JS легко задать стиль элементу
p.style.paddingBottom = '10px'
p.style.width = '100px'


elem.childNodes //Возвращает NodeList, состоящий из дочек элемента.
elem.nextSibling //Возвращает элемент непосредственно следующий за данным узлом в списке
//childNodes его родительского элемента.
elem..previousSibling //Возвращает предшествующий "соседний" элемент.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

event.stopPropagation()
/*Всплытие событий. Если событие привязано к внешнему элементу, 
то оно сработает и на всех внутренних элементах. 
Кликнув на Р в примере ниже, сработают все три события. 
При этом this и event.target будут разными. Всплывают почти все собтыия, 
за исключением например focus. Всплытие идёт с «целевого» элемента прямо наверх. 
По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, 
а иногда даже до window, вызывая все обработчики на своём пути.

this - это элемент, в который было записано событие (меняется по мере всплытия)
event.target - элемент, на который кликнули (в процессе всплытия он остается неизменным)

<form onclick="alert('form')">
  <div onclick="alert('div')">
	<p onclick="alert('p')">P</p> //элемент с самой большой вложенностью.
  </div>
</form>*/

event.stopPropagation()
//Не позволит событию всплыть выше по модели ДОМ, 
//чем элемент, который вызывает эту команду.
//event.stopImmediatePropagation() - не только не пускает дальше, 
//но и прекращает выполнение событий на текущем элементе.

/*Погружение событий - перед тем как сработать, событие идет по модели 
ДОМ до элемента. Чтобы отследить этот момент, необходимо добавлять событие следующей командой.*/

elem.addEventListener(..., true)// где true - это сокращенная версия {capture: true}. 
//По умолчанию capture имеет значение false, что позволяет перехватывать событие только при всплытии.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Ползовательские элементы (customElement)
//Стоит отметить, что 
//Для начала нам нужно расширить класс из базового класса HTMLElement.
class CustomElem extends HTMLElement{
}

  //Далее добавим туда методы для работы с ним.
connectedCallback() //срабатывет тогда, когда компонент добавляется в документ.
//в этой функции мы можем работать с элементом через this.
connectedCallback() {
	this.innerHTML = `<h1>Hello World...</h1>`
	this.style.color = "red"

	//именно в этом методе рекомендуется проводить рендеринг нашего элемента.
}

disconnectedCallback() //вызывается, когда элемент удаляется из документа.

//После созания класса необходимо зарегистрировать элемент
customElements.define('my-element', CustomElem)
//Чтобы гарантировать отсутствие конфликтов между встроенными и пользовательскими элементами,
//пользовательское имя должно содержать дефис.

//Также можно наследовать не только базовый класс HTMLElement, но и например HTMLButtonElement,
//Если наш пользовательский элемент будет кнопкой.

=====================================================================================================

ФУНКЦИИ
//Собственно, нужны для запуска определенного кода многократно.
//Не стоит перегружать функцию, одна функция должна выполнять одно действие.
//Лучше ввести дополительные, реализующие ограниченный функционал.
//Принцип единственной ответственности должен работать и здесь.

Замыкания в JS
/*Для того, чтобы понять эту тему, необходимо понять, что такое лексическое окружение.
Иногда его называют лексической областью видимости.
У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению.
В пером хранятся данные об объявленных переменных и функциях, второе хранит ссылку к внешнему окружению.

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, 
затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в strict mode. 
Без strict mode, для обратной совместимости, присваивание несуществующей переменной 
создаёт новую глобальную переменную с таким именем.

Вложенная функция - функция, которая вложена в другую. Соответственно, первая функция становится
для нее областью видимости. Если очень кратко, то замыкание - это когда внутренняя область одной
функции становится внешней для вложенной в нее. Говорят, что внутренняя функция замкнута на внешнюю.*/

function sayHello (name){
	return function (phrase){
		console.log(`${name} says: ${phrase}`);
	}
}
let callIgor = sayHello('Igor'); //замкнули с переменной name
/*Теперь в переменной callIgor лежит внутренняя функция, так как ее мы возвратили вызовом sayHello('Igor').
Получается, что нам нужно вызывать callIgor(), передавая в него фразу.
Можем сказать, что замкнули внутренню функцию на внешнюю sayHello. Внутрення функция будет брать значение
name из внешней области видимости, а именно то, которое мы передали в sayHello.*/
callIgor('Hello!'); //Igor says: Hello!
callIgor('Fuck you!'); //Igor says: Fuck you!

//Если функция объявлена внутри блока, например в if, то за его пределами ее вызов будет ошибкой.

//Замыкание для sum(5)(4):
function sum(a){
	return function(b){
		return a + b;
	}
}

//===================================================
/*Когда функция модифицирует некоторую переменную, то процесс идет так же. Она модифицируется там, где
была найдена. Таким образом, мы можем с каждым вызовом функции увеличивать переменную*/
function count() {
	let count = 0
	return function() {
		count++
		console.log(count)
	}
}

const counter = count() //де-факто counter = внутрення функция
//Каждый раз, когда мы будем вызывать counter, он будет находить нужную переменную во внешней области
//видимости, на которую замкнут, то есть во внутренней области видимости count(), и увеличивать ее там.
counter() //1
counter() //2 т.к. лексическое окружение изменилось

//Если же заново вызвать count(), то значение обнулится
const newCounter = count()
newCounter() //1

/*Замыкание позволяет прежду всего решить проблему счетчиков. Эта проблема заключается в том, что если
мы будем использовать в счетчике переменную из глобальной области видимости, то ее кто-то может перезадать.
Замыкние позволяет инкапсулировать эту переменную. В нашем примере мы инкапсулировали переменную count.

Можно сделать, например, генератор сетевых адресов:*/
function generator (domain) {
	return function (url) {
		return `https://${url}.${domain}`
	}
}

const comUrl = generator('com')
const ruUrl = generator ('ru')

const vk = ruUrl('vkontakte') //https://vkontakte.ru
const google = comUrl('google') //https://google.com

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Парметры Spread и Rest (...)
/*Иначе их называют оператор расширения и остаточный параметр. Введены в ES6.
По сути, они выполняют сходное действие, но, если spread разворачивает массив,
преобразуя его в цепочку значений, то 
rest наоборот, создает массив из набора значений.

Собственно, отличить их можно так: rest используется только как
крайний справа параметр функции, который можно передать,
в остальных случаях - это spread.
То есть, когда мы передаем параметры в функцию и используем ..., это будет spread,
но когда мы используем ... при объявлении функции, это уже будет rest.
Пример:*/
funcTest(1, 2, ...someArray) //spread
function funcTest (a, b, ...args) { //rest
	return a + b + args.reduce((a, i) => a + i)
}


Spread
/*Этот оператор является, собственно, тремя точками. Остальное вариативно.
Он разворачивает массив и передает каждый элемент в качестве параметра.*/
const cities = [Moscow, Spb, Kazan, Ufa, Tumen, Kurgan]
console.log(...cities) //Moscow, Spb, Kazan, Ufa, Tumen, Kurgan

//Spread легко сочетается с другими элементами, например, создадим новый массив
//из двух старых и некоторых новых элментов.
var arr2 = [...arr, 2, 'text', ...arr1]

//Для объектов Spread применяется как средство для поверхностного клонирования 
//(это будет новый объект, но свойства все равно будут от оригинала)
obj2 = {...obj1}
//или объединения объектов
obj3 = {...obj1, ...obj2}
//При этом, если у объектов были одинаковые свойства, то в приоритете будет то,
//которое принадлежит крайнему справа объекту (smart merge).

//Часто применяется в Math
const numbers = [1, 44, 67, 88, 45, 31]
Math.max(...numbers) //передаем в функцию значения из массива.

//Можно применить и к строке, чтобы сделать из нее стандартный массив.
//Сначала разбиваем строку на символы, а потом при помощи [] делаем из них массив.
let str = 'I\'m a string!'
console.log([...str])


Rest
/*Делает в точности противоположное. Он собирает оставшиеся параметры и создает из них
массив.
После rest уже не должны быть переданы никакие параметры.*/

//Применяется, когда в параметры функции может передаваться неограниченное число значений.
function testSpread (...args) {
	//Здесь rest, так что в функцию попадет массив, можно пройтись по нему.
	for (let arg of args) {
		console.log(arg)
	}
}

//Либо когда часть параметров принимет функция, а остальные необходимо положить в массив.
function personInfo (name, surname, ...rest) {
	console.log(`${name} ${surname} is ${rest[0]}`)
}
personInfo('July', 'Caesar', 'Imperor')

//Если ничего не передать в rest, то он будет просто пустым массивом.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

функция-генератор*
/*function* - это функция-генератор. 
Она может прерваться во время выполнения и возвратить промежуточный результат,
а потом в произвольный момент времени продолжать свое выполнение.

При запуске такой функции самой по себе, ее код не выполняется, 
вместо этого она возвращает генератор.

Генератор - это объект особого типа. Это замороженный вызов функции.*/

.next()
/*Основной метод работы с ним это .next(). Он возвращает JSON, 
где первое поле - значение, второе булеан, который определяет, завершена ли функция. 
В метод next() можно также передавать значения, они попадут обратно в генератор на следующий вызов. 
Так можно взаимодействовать с генератором.

Если функция дошла до конца (последнее значение return), 
то все следующие запуски будут возвращать значения done: true. 
Он начинает, либо продолжает выполнение генератора до следующего ключевого слова yield. 
То есть с ней нужно работать так:*/

function* generator () => { //объявление функции
	yield 1;
	yield 2;
	return 3;
}
let generate = generator(); //возвращаем генератор и присваиваем его в переменную

let first = generate.next(); //присвоит first значение JSON, где 
//{value: значение из yield, done: false/true} Иными словами:

console.log(JSON.stringify(first)); // {value: 1, done: false}

//Часто его используют как итератор. 

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
	alert(value); }
// 1, затем 2, а 3 не выведется, так как циклы не работают с return(done: true), 
//вместо этого для корректного отображения нужно указать три поля yield.


Композиция генераторов
//Композиция генераторов это по сути заключение одного генератора в другой. 
//При каждом вызове внешнего
//генератора будут выполняться все действия внутреннего.
;
function* generateSecuence (start, end) { //генератор для вставки внутрь
	for (let i = start; i <= end; i++) {
		yield i;
	}
}

function* generateSomeNums () { //Внешний генератор
	yield* generateSecuence(1, 5)
	yield* generateSecuence(7, 10)
}

//Если пробежаться по внешнему генератору циклом и составить из результатов строку,
//то мы получим:

let str = ''
let generator = generateSomeNums()
for (let value of generator) {
	str += value
}
//str = '1234578910'


/*Взаимодействие с генератором.
Получаем из генератора запрос, образно говоря,
взаимодействуем с ним, выполняем любые асинхронные операции, а потом
передаем результат обартно в генератор и продолжаем его выполнение.*/

function *gena () {
	let surname = 'Smith'
	let name = yield "name" //Нам нужно значение name 
	let fullname = name + surname
	alert (fullname)
}

let generator = gena()
let query = generator.next().value //получаем запрос "name", генератор стоит
//Some code, ищем name
generator.next('John') //передаем в генератор значение и продолжаем его выполнение
//Функция генератор завершит выполнение с полученными данными.

/*Чаще всего генераторы используются в т.н. плоском асинхронном коде. 
В этом случае генератор yield'ит промисы.
Когда промис выполняется, то специальная функция. работающая с генератором, снова
запускает его, передавая в next() значение выполненного промиса.
Это называется библиотека co*/


/*Можно создать собственный аналог генератора при помощи обычной функции-метода в объекте.
iteretor - object*/
const iteretor = {
	gen (n = 0) { // [Symbol.iterator] чтобы можно было пробежаться for of
		let i = 0
		//возвращаем next, чтобы было удобнее работать
		return {
			next() {
				if (i < n) {
					return {value: ++i; done: false}
				}
				return {value: undefined; done: true}
			}
		}
	}
}
//Поместим в переменную метод объекта
const itr = iterator.gen()
itr.next() //Вызываем генератор


=====================================================================================================

СОБЫТИЯ

/*События мыши

Бывают базовые и комплексные.

К базовым относятся такие как:
mousedown/mouseup - нажал или отпустил любую кнопку мыши,
mouseover/mouseout - навел или убрал курсор,
mousemove - любое движение мыши над элементом,
contextmenu - открытие контекстного меню ПКМ.

К сложным относятся такие как:
click
dblclick

События могут перекликаться, то есть, например, при клике на 
элементе будет выполнена последовательность:
mousedown
mouseup
click

У каждого события мыши есть свойство which, определяющее нажатую кнопку.
Оно может иметь всего три значения:
event.which == 1 – левая кнопка
event.which == 2 – средняя кнопка
event.which == 3 - правая кнопка

Также есть свойства, определяющие нажатые одновременно кнопки:
shiftKey: Shift
altKey: Alt 
ctrlKey: Ctrl
Они равны true, если была зажата соответствующая кнопка.

clientX, clientY -свойства события, указывающие коррдинаты курсора при исполнении события.
Координаты осчитываются от размеров окна.

Также интересные моменты:
Если выставить element.oncopy = return false, то это запретит копирование.
Если выставить element.onmousedown = return false, то это запретит выделение текста.*/

=====================================================================================================

АСИНХРОННОСТЬ

асинхронность в JS
/*JS это однопотчный яп. Однопоточный значит - имеет один стэк вызовов.
Синхронность - означает, что пока выполняется первая строка, вторая не будет выполнена. 
В одну единиц времени может быть выполнено лишь какое-то одно действие.*/

/*Есть данные, которые изначально содержаться в JS в формате кучи (heap). 
При синхронном выполнении JS закидывается в стек, выполняется, достается оттуда 
и только потом туда закидывается следующая строка(команда).
При выполнении функции в функции (например, рекурсия), 
стек вызовов наполняется ими, пока не дойдет до последней вложенной. 
Далее все начинает раскурчиваться обратно. Выполняется самое верхнее действие в стеке. 
Максимальный объем действие в стеке - 16 тысяч. Если лимит превышен - то движок JS V8 очищает его.

Асинхронность - первая строка запускается в фоновом режиме, позволяя второй не дожидаться ее окончания. 
Если бы не было асинхронности, то сайты бы зависали, ожидая выполнения какой-либо команды, 
и не работал бы никакой функционал.

Самый наглядный пример на JS это setTimeout()*/

console.log(1)
setTimeout(() => {
	console.log(2)
}, 2000)
console.log(3)

/*Выведет 1,3,2. setTimeout попадая в стек вызовов, уходит из него невыполненным, уступая место 3. 
А затем возвращается обратно (через 2 секунды) и выполняется. 
Куда ходил таймер? 
Тут вступают в игру Web Api и Event Loop.*/

Event loop
/*Когда setTimeout попадает в очередь запросов, он не выполняется, а перемещается оттуда в Web API. 
Там он ожидает указанное время. В это время стек пустой, и туда попадют другие строки кода. 
По прошествии 2 секунд он должен отправиться в стек. 
Но у Web API нет права закидывать что-либо напрямую в стек, так что он отправит setTimeout 
в очередь задач (Task queue или callback queue). 
Event Loop (цикл событий) добавляет первое событие в списке в стек, когда стек пустой. 
У нас одно событие, так что оно сразу попадет в стек и выполнится. 
Благодаря этому события из Task queue попадают в стек вызовыв по очереди.*/

setTimeout
/*Кстати говоря, setTimeout гарантирует лишь минимальную задержку, так как когда он попадет в 
Event loop, стек вызовов может быть переполнен.*/

Render queue
/*Помимо этого, есть Render queue (обновление экрана, опять же работает лишь когда стек вызовов пустой).
Каждые 16 мс, или 60 раз в секунду, он при наличии пустого стека вызовов обновляет экран. 
Render queue имеет приоритет над Task queue, так что Event loop всегда будет давать им 
просочиться между событиями из Task queue. 
Таким образом, асинхронные действия, приходящие из Task queue, не будут мешать странице обновляться. 
Из этого следует, что все сложные анимации и затратные операции не стоит делать синхронными, 
иначе они будут вызывать фризы экрана.*/

Event listeners
/*События при нажатии кнопки, слушатели событий - все находятся в Web API, 
они попадают туда сразу же при создании подобного события. оттуда они уже попадают в Task queue 
и выполняются при налчии свободного стека вызовов.*/

/*Pyramid of Doom или CallBack Hell - это огромное количество колл-бэков, включенных друг в друга. 
Чтобы такого не было, есть промисы(см. далее).*/

async () и await функции.
/*Это синтаксический сахар для удобства. Можно и на промисах то же самое делать.
Эти команды компилируются в промис перед запуском при помощи babel

Async перед функцией означает, что она вернет промис. 
Промис с результатом, который мы передаем в ретурн. 
Фактически с тем же успехом можно вернуть функцией промис return new Promise. 
Await используется ТОЛЬКО внутри Async (возвращающих промис) функций. 
По факту это эквивалент метода промисов then. 
Он также не мешает коду выполняться дальше, ожидая заврешения промиса. 
Если есть желание использовать await на верхнем уровне вложенности, 
то достаточно просто обернуть ее в анонимную стрелочную async функцию.
Пример:*/

(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();

/*Если промис, которого ждет await закончится с ошибкой (reject), то автоматически 
будет выброшено исключение, как при throw. 
Его можно отлавливать через блок try-catch. 
Блоком try можно охватить неограниченное количество промисов, и все ошибки отловит catch.*/

.then == await promise //это одно и тоже

async function f() {
	let promise = new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('Ready!')
		}, 1000);
	});
	let result = await promise; //ждет выполнения промиса
	console.log(result)	//не выполнится, пока не завершится предыдущая строка
}

f()
console.log('Are you ready?') //выполнится первым, так как функция асинхронна.


//В асинхронных функциях обязательно нужно отлавливать ошибки.
//Для этого оборачиваем их в блок try/catch
async function fetchUrl () {
	console.log('Fetch started')
	try {
		const response = await fetch(url)
		const data = await response.json()
		console.log('Data: ', data)
	} catch (e) {
		console.error(e)
	} finally {
		console.log('Program ends')
	}
}

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Промисы (Promise)

/*Promises упрощают асинхронность. Собственно внутри него пишется асинхронный код. 
Промис нужен, чтобы соединить создающий и потребляющий участки кода. 
Чтобы не посылать бесконечно запросы, а дождаться выполнения и сразу же запустить другой код, 
который зависит от данных первого. При этом промис не мешает запуститься остальной части кода, 
которая не зависит от него. Также плюс промисов в том, что они могут отлавливать ошибки.
Итак, еще раз, они - просто удобная форма для записи асинхронности. 
Можно создавать цепочку промисов при помощи chaining, просто возваращая в then новый промис.*/

console.log('Requesting data...')
const p = new Promise((resolve, reject) => {
	setTimeout(() => {    //происходит асинхронная операция внутри промиса
		console.log('Preparing data...')
		const backendData = {
			server: 'aws',
			status: 'working'
		}
		resolve(backendData) //выполняет промис и передает дальше данные
	}, 2000)
})

p.then((data) => { //then запускает коллбэк после выполнения промиса с переданными данными
	return new Promise((resolve, reject) => { //возвращает новый промис из метода then
		console.log('Modifying data...')
		setTimeout(() => {    //происходит асинхронная операция внутри промиса
			data.modified = true;
			resolve(data) //передает изменные даные
		}, 2000)
	})

})  
	.then((modifiedData) => { //этот then уже от вложенного промиса
		console.log('Data received...', modifiedData)
	})
	.catch((err) => {
		console.error('Error: ', err) //в случает reject у прошлого промиса выведет ошибку
	})
	.finally(() => {
		console.log('Finish!') //выполнится в любом случае
	})


/*Использование промисов в функциях. Они запускаются одновременно, но заканчивают действие 
в разное время. Обе функции выполняются асинхронно, т.е. одновременно. 
С этими функциями можно работать методами промисов, так как они возвращают промис.*/

const sleep = (ms) => { //функция возвращает промис
	return new Promise (resolve => {
		setTimeout(() => {
			resolve();
		}, ms) //таймер сработает через ms секунд
	})
}

//теперь можно вызывать эти функции и они будут выполняться асинхронно.
sleep(2000).then(() => {
	console.log('after 2 seconds') //работаем методами промиса
})


Методы промисов
/*К ним относятся уже перечисленные выше .then, .catch, .finally
Еще два важных метода промисов это .all и .race. Например:*/
Promise.all([Promise1, Promise2]).then(() => {
	console.log('Это сработает лишь тогда, когда выполнятся и Promise1 и Promise2');
})

/*Они работают с массивами промисов и выполняются либо когда все промисы 
(или функции, возвращающие промис) выполнены, либо когда хотя бы одна из них (race)*/

/*Но у этих методов есть небольшая проблема. .all замыкается, когда будет отклонен 
хотя бы один промис, соответственно. другие не выполнятся. .race замыкается после первого 
выполненного промиса, значит, другие не исполнятся. На помощь приходит:*/
Promise.allSettled([promise1, promise2, promise3])
//Метод возвращает промис, который будет содержать результат выполнения всех промисов,
//неависимо от того, положительный он или отрицательный.


Массивы промисов (цикл for await)
/*Для работы с массивами промисов или перебора других итерируемых
асинхронных объектов используется:*/

asyncronius = [promise1, promise2, promise3].
for await (let num of asyncronius)

/*Обычные итераторы не работают с асинхронными командами. 
Они не будут ждать, когда выполнится функция или промис, так что если нам нужен 
результат предыдущей итерации для рассчета новой, например при использовании forEach, 
то получится ошибка.*/

//Плюс данного цикла в том, что он будет делать цикл с ожиданиями между каждым выполнением.
//Но стоит помнить, что await работает лишь в асинхронных функциях.
//Верная запись:
async function func() {
	for await (let num of asyncronius)
}
func()


=====================================================================================================

КЛАССЫ

/*В ООП классы - это расширяемые шаблоны кода, предназначенные для создания объектов.
Они устанавливают начальные значения и методы.
В первую очередь, классы нужны для более удобного создания объектов.

Объекты, созданные через класс, являются их наследниками.
Они наследуют их методы.
В __proto__ объекта будут все методы его родительского класса.

Методы класса не разделяются запятой, либо ничего, либо ;

По своей сути классы в JS - это функции для создания объекта.
В общем и целом можно обойтись без них, переписав код на простых функциях.
typeof Class = 'function'
Конструктор может быть вызван только при использовании ключевого слова new.*/

class Animal {
	hasTail = true //базовое свойство, которое просто скопируется в объект.
	static type = 'Animal' //статическая переменная, доступна только в классе, в объектах - нет

	constructor(options) { //здесь задаем параметры, которые нужно будет указать при создании.
		this.name = options.name
		this.age = options.age
	}

	voice(){ //задаем методы, которые будет наследовать объект
		console.log('I am animal!')
	}
}

//Создадим объект на основе класса
const animal = new Animal ({
	name: 'animal',
	age: 5
})

//Классы могут обеспечить полноценное наследование. Мы можем
//создавать классы на освное классов. Все методы из родительского класса наследуются.

class Cat extends Animal {} //родитель и потомок идентичны по набору свойств и методов

//В случае создания объекта на основе дочернего класса
//Если мы хотим добавить новые свойства, которые будут присущи 
//лишь дочернему классу, то мы реализуем ключевое слово super()
//Без этого только лишь с новым свойством будет ошибка.

class Cat extends Animal {
	static type ='CAT'

	constructor (options) {
		super(options) //реализует свойства, указанные в родителе
		this.color = options.color //добавляем новое свойство
	}

	//добавляем новые методы в дочерний класс
	get ageInfo () {
		return this.age * 7
	}
}

//Practice. Практическое применение классов в работе с сайтом.
//class Component (и его дочерние классы) будет любому элементу присваивать методы,
//позволяющие скрывать и показывать их.
class Component {
	constructor (selector) {
		this.$el = document.querySelector(selector) //присваиваем элемент из DOM
	}

	hide() {
		this.$el.style.display = 'none'
	}

	show() {
	   this.$el.style.display = 'block' 
	}
}

class Box extends Component { //создает квадрат на основе класса Component.
	constructor (options) {
		super(options.selector)
		this.$el.style.width = options.size + 'px'
		this.$el.style.height = options.size + 'px'
		this.$el.style.background = options.background
	}
}

const box = new Box ({ //создаем объект на основе класса Box
	selector: '#box',
	size: 100,
	background: 'red'
})
//Далее на основе этого кода мы даем любому элементу айдишник #box и он
//будет принимать форму, котору юмы задаем, создавая Box.

class Circle extends Box {
	constructor (options) {
		super(options)
		this.$el.style.borderRadius = '50%'
	}
}

//Как и у функций, у классов есть class declaration(стандартная запись)
//и class expression:
let MyClass = class {
	//constructor
	//methods
}


=====================================================================================================

МАССИВЫ И ИХ МЕТОДЫ

Псевдомассивы и итерируемые объекты
/*Итерируемый объект - это объект у которого есть метод Symbol.iterator
Иначе говоря, по нему можно пробежаться циклом for of*/

/*Псевдомассив - это объект, имеющий индексы и свойство length*/
let arrayLike = { 
  0: "Hello",
  1: "World",
  length: 2
}

//например строка - это и псевдомассив и итерируемый объект

//Проблема в том, что с ними нельзя работать, как с полноценными массивами
//Неприменимы методы push, pop и т.д. 
//На помощь приходит
Array.from(pseudoArray, fucntion)
//Function - необязательный второй аргумент, который может преобразовывать элементы
//Например, можно сделать из строки массив.
Array.from('foo')
// ['f', 'o', 'o']

Array.from('abc', char => char + char)
// ['aa', 'bb', 'cc']

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Методы массивов

Array.forEach((item, i, array) => {}, thisArg)
/*Используется для более элегантного перебора массива, чем обычный цикл.
К каждому элементу применяется функция-коллбэк.
Функции-коллбэку передает три параметра: 
item - текущий элемент массива,
i - индекс текущего элемента массива,
array - перебираемый массив.
thisArg - второй необязательный аргумент, передающий контекст в функцию.

Этот метод не меняет исходный массив и возвращает undefined*/

---------------------

Array.map((item, index, array) => {}, thisArg)
/*Один из самых часто используемых методов, он принимает массив и реализует
клллбэк для каждого элемента.
Особенность метода в том, что он возвращает новый массив, уже из обработанных элементов.
При этом старый массив НЕ изменяется. В этом большой плюс метода.

Функции-коллбэку передает три параметра: 
item - текущий элемент массива,
i - индекс текущего элемента массива,
array - перебираемый массив.
thisArg - второй необязательный аргумент, передающий контекст в функцию.*/

---------------------

Array.sort([compareFunction])
/*Метод сортирует массив, по умолчанию - в алфавитном порядке.
Но если задать compareFunction, то будет сравниваться по указанному алгоритму.

compareFunction действует следующим образом:*/
function(a, b) {
	if //условие, которое нужно нам
	return
}
/*Если функция возвращает отрицательное число(обычно юзают -1), то
это говорит методу, что a меньше b. Метод поставит a впереди b.
Если функция возвращает 0, то метод оставит элементы без изменений.
Если функция возвращает число, больше чем 0, то это говорит о том, что 
a > b, а занчит метод переставит a дальше, чем b.

Метод относится к 'in-place algorytm'. 
Это значит, что он меняет тот объект, к которму применяется. 
Он возвращает отсортированный массив, но это не важно, тк массив меняется
уже после применения метода.*/

---------------------

Array.filter((item, index, array) => {}, thisArg)
/*Метод создает новый массив со всеми элементами, прошедшими проверку.
Если не один из элементов не пройдет тест, то бует возвращен пустой массив.
Для каждого элемента вызывается функция-коллбэк и, если она возвращает true
или значение, котрое можно привести к true, то элемент попадет в новый массив.

Изначальный массив при применении метода не изменяется.

Возвращает новый массив.

Функции-коллбэку передает три параметра: 
item - текущий элемент массива,
i - индекс текущего элемента массива,
array - перебираемый массив.
thisArg - второй необязательный аргумент, передающий контекст в функцию.

Интересный пример:
Фильтрация массива и возвращение массива из только положительных значений.*/
const arr = [0, null, 42, undefined, "", true, false, NaN, "", "foo bar"];
const trueOnly = arr.filter(Boolean); //Этого достатчно
/*Все дело в аргументе Boolean.
Обычно используется как Boolean(value)/
Это функция, вызывая которую, вы приводите value к булевому типу.*/

---------------------

Array.find((item, index, array) => {}, thisArg)
/*Метод возвращает значение первого элемента, который удовлетворит условию коллбэка.
Если коллбэк возвращает true, то текущий элемент и будет возвращен.
Метод пробегается по всем элементам массива, что может быть затратно.
Если элемент не нашелся, вернется undefined.

Изначальный массив при применении метода не изменяется.*/

---------------------

Array.findIndex((item, index, array) => {}, thisArg)
/*Действует схожим образом с и Array.find.
Разница в том, что возвращает не элемент. удовлетворяющий условию, а его индекс.
Если элемент не нашелся, вернется значение -1.

Изначальный массив при применении метода не изменяется.*/

---------------------

Array.reduce((previousValue, currentValue, index, array) => {}, initialValue)
/*Метод применяет функцию reducer к каждому элементу массива слева направо.
initialValue - это значение принимает previousValue при первом вызове функции,
при этом currentValue примет значение первого элемента массива.
В ином случае значение previousValue будет равно первому элементу массива,
а currentValue - второму элементу.

Зачастую previousValue называют аккумулятором.

index, array - необязательные аргументы коллбэка.
Метод возвращает результат последнего вызова функции-коллбэка.

При вызове коллбэка для каждого нового элемента, previousValue имеет значение 
предыдущего вызова коллбэка.
Несколько примеров:*/
//Суммирование всех значений в массиве
var sum = [0, 1, 2, 3].reduce((a, b) => a + b)

//Разворачивание массива массивов
var flattend = [[1, 2], [3, 4], [5, 6]].reduce((a, b) => a.concat(b))

---------------------

Array.concat(array, ...)
/*Метод склеивает массив, к которому применяется с массивом/массивами,
переданными в аргумент метода.

Возвращает новый массив.

Можно соединять не только массивы, но и обычные значения, например*/
arr = Array.concat(1, [2, 3], array)

---------------------

Array.reduceRight((previousValue, currentValue, index, array) => {}, initialValue)
/*Метод работает точно так же, как и обычный reduce().
Разница заключается в том, что он начинает считать элементы справа-налево.

Если не указан initialValue, то previousValue примет значение последнего элемента,
а currentValue примет значение второго элемента с конца.*/

---------------------

Array.flat([depth])
/*Уменьшает уровень вложенности массива на указанную depth.
По умолчанию уменьшает ее на 1.
Применяется для "массива массивов" с любым уровнем вложенности.

Возвращает новый массив.

Кроме этого, метод удаляет пустые слоты из массива.*/

---------------------

Array.isArray(obj)
/*Метод проверяет, является ли указанный  obj массивом. Возвращает
true или false в зависимости от результата.

Не изменяет сам obj.*/

---------------------

Array.reverse()
/*Метод переставляет все значения в массиве наоборот(первое станет последним итд).
!!Метод изменяет исходный массив.

Возвращает ссылку на измененный массив, к которому был применен.*/

---------------------

Array.slice(begin, [end])
/*Метод применяется для того, чтобы получить часть массива.
Похож на одноименный метод строки.

begin - номер индекса, с которого начинать извлечение.
end - идекс, на котором извлечение следует закончить.

Поддерживаются отрицтаельные значения параметров, в этом случае счет будет идти
с конца обрабатываемого массива. Так же, как в одноименном методе для строки.

Важно то, что если скопировался объект (который был элементом исходного массива),
то в возвращенном куске будет лишь ссылка на него (не иммутабелен). Для примитивов
работает полноценное копирование.

Не меняет исходный массив. Возвращает массив с выбранной частью исходного массива.*/

---------------------

Array.splice(start, [deleteCount], [addedElems])
/*Применяется для удаления элементов из массива или вставки элементов в него.

start - номер  элемента, с которго начинать удаление или вставку.
deleteCount - число удаленных элементов. Если равно нулю, то будет лишь добавление
(но тогда нужно указать доабвляемый элемент). Если упустить второй параметр, то будет удален
весь массив после start.
addedElems - те элементы, которые мы хотим добавить а массив. Можно указывать несколько.

Если количество указанных вставляемых элементов будет отличным от количества удаляемых 
элементов, массив изменит длину после вызова.

Возвращает массив, содержащий удаленные элементы. Изменяет целевой массив.*/

---------------------

Array.fill(value, [start], [end])
/*Метод заполняет массив значениями value (на всю его length). При указании параметров start и end
заполняет от индекса с номером start до индекса с номером end.*/

---------------------

Array.toString()
/*Метод возвращает строковое представление массива. Собственно, строка будет
состоять из элементов массива, разделенных запятой.

Метод перезаписывает глобальный метод объекта Object.toString()*/

=====================================================================================================

ОБЪЕКТЫ И ИХ МЕТОДЫ, this, .prototype 

/*Объект - это особый сложный тип данных. Его свойства могут быть перечислимыми (enumerable)
и неперечислимыми. Встроенные методы, наследуемые объектами, являются неперечислимыми, 
а свойства, добавляемые в объекты вашей программой, являются перечислимыми.
Чтобы сделать свойство перечислимым, достаточно добавить к нему enumerable: true.*/
c: 'Hello!' //неперечислимое

c: {
	value: 'Hello!', //перечислимое
	enumerable: true
}


/*Чтобы прототип объекта не потерялся, нельзя задавать его целиком, необходимо лишь вписывать в 
него определенное свойство.*/
Object.prototype = {
	someFunc: function()
}
//Нужно писать так:
Object.prototype.someFunc: function()


Цикл for (let value in obj)
/*Не делает различия между объектом и его прототипом, проходится по всем свойствам (properties).
При условии что эти свойства перечисляемые.
Для того, чтобы этого избежать есть метод*/
object.hasOwnProperty('property')

for (let value in obj) {
	if (obj.hasOwnProperty('property')) {
		//some code
	}
}

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Object.create()
/*Создание объекта через Object.create(prototype) обладает рядом особенностей.
В данном случае мы задаем свойства объекта как объекты (через property descriptors).
По умолчанию они false.
Прототипом в этом случае выступает пустой объект.*/

Object.create({}, {
	name: {
		value: 'Yury',
		enumerable: true, //определяет можно ли пробегать по нему циклу
		writable: true, //определяет можно ли изменять свойство
		configurable: true //определяет, можно ли удалять свойство
	},

	age: {
		...
	}
})


Дескрипторы свойств
//Получить дескриптор можно при помощи
Object.getOwnPropertyDescriptor(object, propertyName)
//Возвращает объект-дескриптор свойства
{value: x, enumerable: false, ...}
//Изменить дескриптор свойства можно след. образом

//Получить все свойства объекта с дескрипторами.
Object.getOwnPropertyDescriptors(object)

Object.defineProperty(object, 'propertyName', {
	writable: false
})
//Определить сразу несколько свойств
Object.defineProperties(obj, { //obj - новый или старый объект, которому определяют свойства.
	propX: {value: 'x', writable: true},
	...
})

//Также все это можно настраивать глобально для всех свойств объекта.
Object.preventExtensions(obj) //Запрещает добавлять новые свойства
Object.seal(obj) //Запрещает добавлять/удалять свойства.
//Устанавливает configurable: false для всех существующих свойств.
Object.freeze(obj) //Запрещает добавлять, изменять, удалять новые свойства.

Object.entries() //Преобразовать объект в массив пар
Object.fromEntries() //Преобразовать массив пар в объект


/*В целом свойства объекта бывают двух типов. Это
свойства-данные (data properities),
свойства-аксессоры (acsessor properities)*/

Геттер и сеттер
/*Свойства аксессоры - это геттер и сеттер.
По сути это просто куски кода, которые выполняют всю работу за кулисами.
Но при этом обращаться к ним можно как к обычным свойствам объекта JS. 
Причем, сеттер может выполнять практически любые функции, не только внутри объекта.
Пример:*/

let user = {
	name: 'Yury',
	surname: 'Korotovskikh',
	get fullName () {
		return `Full name is ${this.name}, ${this.surname}` //Возвращает что-либо
	},
	set fullName (value) {
		document.body.style.background = 'red' //Можно творить любую дичь
		[this.name, this.surname] = value.split(' ')//Изменять свойства объекта через this
	}
}

//Другой вариант записи геттера/сеттера, в этом случае вызывается по-другому.

let user = {
	name: 'Yury',
	surname: 'Korotovskikh',
	fullName: {
		get () {
			return `Full name is ${this.name}, ${this.surname}`
		},
		set (value) {
			document.body.style.background = 'red'
			[this.name, this.surname] = value.split(' ')
		}
	}
}

//Свойство объекта может быть либо аксессором, либо свойством с данными. 
//При попытке указать в одном дескрипторе  свойства и get, и value в одном будет ошибка.

//Геттер и сеттер также используются и во внутренних переменных объекта _var.
//В целом их можно изменять через:
Object._var = ...
//Но по негласному соглашению так не принято делать, поэтому то же самое делается
//через сеттер, в который выставляется условие:

let user = {
	get name () {
		return this._name
	},
	surname: 'Korotovskikh',
	set name (value) {
		if (typeof value != 'string') {
			console.log('Type a string.')
			return
		} else {
			this._name = value
		}
	}
}

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Методы объектов

Object.assign(target, ...sourses)
/*Копирует в target свойства объектов sourses(может быть несколько).
Копирует только перечисляемые и собственные свойства.
Проверить, является ли свойство таковым можно при помощи
propertyIsEnumerable(), hasOwnProperty().

Метод относится к неглубокому клонированию объектов.

Возвращает объект target (с добавленными свойствами)*/

---------------

Object.keys(obj)
/*Возвращает массив из названий свойств (ключей объекта)
Метод возвращает только перечисляемые свойства и только свойства, которые принадлежат
непосредственно объекту. Иначе говоря, работает как цикл for in, но цикл перечисляет
свойства из цепочки прототипов, а метод нет.

Не изменяет объект. Возвращает новый массив.*/

---------------

Object.values(obj)
/*Возвращает массив из свойств объекта. Работает как цикл for in, но опять же метод выдает
только собственные перечисляемые свойства объекта, а цепочку прототипов игнорирует.

Не меняет сам объект.*/

---------------

Object.getOwnPropertyNames()
/*Возвращает массив из свойств (ключей объекта)
Отличие метода от Object.keys в том, что он возвращает массив из всех собственных
свойств объекта, а не только из перечисляемых. Свойства из цепочки прототипов так же 
не учитываются.

Не изменяет объект. Возвращает новый массив из перечисляемых и неперечисляемых свойств.*/

---------------

Object instanceof Constructor 
/*Метод возвращает true, если Object был создан при помощи Constructor,
либо если Constructor находится в его цепочке прототипов (является струткурой
более высокого уровня).*/

---------------

Object.create(protoObj, [propertiesObject])
/*Метод возвращает новый объект, прототипом которого будет объект protoObj.
propertiesObject - необязательный параметр, в котором можно передать новые свойства для объекта.
Например:*/ 
const dog = Object.create(animal, {
  breed: {
    value: 'Siberian Husky'
  }
})
//Но предпочтительнее совместить с методом Object.assign
const dog = Object.assign(Object.create(animal), {
breed: {
    value: 'Siberian Husky'
  }
})

---------------

Object.toString()
/*Встроенный метод объекта, который наследуют все типы данных в JS
Если этот метод не переопределён в пользовательском объекте, toString()
возвращает строку вида "[object тип]", где тип — это тип объекта.
Например, объект вернет [object Object], null - [object Null], undefined - [object Undefined].*/ 

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Прототипы .prototype, __proto__

/*Цепочка наследования - важная часть языка JavaScript. Она представляет собой организованную
связь между объектами, их прототипами и родительскими классами.

У каждого объекта есть __proto__. Если мы вызываем свойство, то оно сначала ищется в 
самом объекте, а потом в его прототипе.
Object - самый глобальный класс. Можно записать все что угодно в Object.prototype и тогда для 
любого объекта в документе можно будет вызвать эту функцию.

__proto__ - ссылается на родительский класс. Он одинаковый у всех чисел (глобальный объект число)
и других примитивов.
Все объекты и примитивы создаются через невидимые объекты-конструкторы, которые указаны в __proto__.
__proto__ ссылается на .prototype того конструктора, через который он был создан.

Стоит оговориться, что null и undefined не имеют свойства __proto__*/
'string'.__proto__ = String.prototype

/*Таким образом, .prototype это прототип объекта (или другого типа данных), хранящий методы объекта.
Он есть только у конструкторов, т.е. тех, которые используют для создания данных через new.
Array.prototype, Object.prototype, Date.prototype, Number.prototype, String.prototype, Boolean.prototype.
JS устроен так, что в самом объекте хранятся только данные. Все встроенные методы хранятся в его
прототипе.

.prototype реализует наследование в обратную сторону. Если в .prototype объекта задать метод,
то он будет унаследован всеми другими объектами, созданными на его основе, иначе говоря, теми,
для кого он является прототипом.
Таким образом, .prototype наследуется, передавая методы прототипа.
Мы можем унаследовать по своему выбору, уставновив __proto__ как, например, Array.prototype.*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

this

/*this - ссылается на контекст вызова функции. 
Контекст это то, что слева от точки. Object.function - здесь контекст - это объект. 
This внутри объекта ссылается на сам этот объект.

Контекст вызова функции можно задавать при помощи декортатора.
Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. 
Основная работа по-прежнему выполняется функцией.*/
bind()
let newContext = function.bind(context) //привязываем к function context (как правило context - объект).
//Чтобы запустить функцию нужно вызвать newContext().

//=================================
function.call(context) //работает аналогично bind, но он сразу запускает функцию. После через запятую можно
//передать аргументы для функции. Например:
function say (phrase) {
	console.log(`${this.name} says ${phrase}!`)
}
let user1 = { name: "John" }
say.call(user1, 'Hello') //'John says Hello!'

//=================================
function.apply((context, [argsArray])// - работает как call, но аргументы передаются в массиве. 
//Можно передавать в аргументы как переменную, которой присвоен массив, так и литерал массива.

//У стрелочных функций нет this

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Клонирование (копирование) объектов
/*Бывает неглубоким и глубоким.
Неглубокая копия предполагает клонирование на первом уровне вложенности, но 
на последующих уровнях она просто ссылается на соответствующие свойства объекта-оригинала,
что, собственно, и приводит к традиционной ошибке копирования объектов(ссылка вместо копии).
Защита от этого называется неизменяемостью данных, иначе говоря, иммутабельностью (immutability).

Собственно, чтобюы сделать объект иммутабельным, требуется выполнить глубокое клонирование.
Глубокая копия делает настоящего клона на всех уровнях.
Глубокое копирование гораздо медленнее.

Условимся, что у нас есть объект obj, который мы хотим склонировать в newObj*/

/*Первый способ - использование spread.
Это неглубокое клонирование.*/
newObj = { ...obj }

/*Другой способ - использование Object.assign().
Это тоже неглубокое клонирование.*/
newObj = Object.assign({}, obj)

/*Еще из простых способов есть JSON.

Этот метод делает глубокое клонирование. Но он считается грязным и слишком толстым методом.
Кроме того, JSON не поддерживает функции, Symbol (Symbol('4')), Data и рекурсивные структуры, 
что может стать серьезной проблемой.*/
newObj = JSON.parse(JSON.stringify(obj))

/*Более универсальный способ для глубокого клонирования (на всех уровнях вложенности)
через рекурсию:*/
let obj = {x: 20, y: {z: 30}};

const makeDeepClone = (obj) => {

	let newObj = {}

	Object.keys(obj).map(key => {

		if (typeof obj[key] === 'object') {
			newObj[key] = makeDeepClone(obj[key])
		} else {
			newObj[key] = obj[key]
		}

	})

	return newObj
}

const cloneObj = makeDeepClone(obj)


=====================================================================================================

СЕТЕВЫЕ ЗАПРОСЫ НА СЕРВЕР, JSON

AJAX
/*Сетевые запросы из JavaScript называются AJAX (Asyncronous Javascript And XML).
XML мы использовать не обязаны, просто термин старый, поэтому в нём есть это слово.

Сетевые запросы постоянно исполльзуются в JS, так как нужно:
Отправить заказ
Загрузить товары
Заргистрировать/авторизовать пользователя
Обновить данные
*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Объект URL()
/*Встроенный объект, позволящий удобно создавать и разбирать url-адреса.
Для начала его нужно создать:*/

let myUrl = new URL(url, [base])
//url - полная адресная строка или конкретный путь(если указан бэйс)
//base - необязательный, задает базовый адрес, к которому добавляется url
let urlInistrad = new URL('/profile/admin', 'https://inistrad.info')

//таким образом легко создавать новый url, надстраивая его над старым:

let url = new URL('https://inistrad.info/profile/admin');
let newUrl = new URL('tester', url);
// https://javascript.info/profile/tester

//Объект URL можно передавать в методы fetch и HMLHttpReqest, он будет конвертироваться в строку.


//Url дает доступ к компонентам, поэтому его можно разбирать на части:
//https://site.com/page1
url.href //полный адрес, то же, что url.toString()
url.protocol //https:
url.host //site.com
url.pathname //page1
url.search //?query=JavaScript


searchParams
//Для задания параметров поиска используется спеицальное свойство searchParams
//Его основные методы:
delete(name)// удалить параметр по имени.
set(name, value)// задать/заменить параметр.
//При этом все символы и знаки в параметрах кодируются, например, пробел становится "+"

//Например:
let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!');
// параметр 'q' закодирован
xhr.open('GET', url); // https://google.com/search?q=test+me%21

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

HTTP протокол
/*Чтобы успешно взаимодействовать по сети разным устройствам нужно единое правило работы.
Его принято называть сетевым протоколом. Самый известный из них - Hyper Text Transfer Protocol.
Но помимо этого существует много других, например:
FTP - File Transfer Protocol - для передачи айлов между компьютерами.
Для работы с каждым видом протоклов нужно ПО, для http это бразуер.

Итак, бразуер обращается к ресурсам по протоколу http. http обеспечивает передачу данных между 
сервером и клиентским устройством в соответствии с опред. правилами. Эту технологию называют 
клиент-серверной технологией.

Клиентское устройство отправляет http-запрос на сервер. Там эта информация обрабатывается, и 
отправляется в виде http-ответа обратно на клиентское устройство. Если произошел сбой
или не найдена информация, то  отправляется ошибка.

http-запрос состоит из трех частей:
1. Строка запроса (request line) - указывает метод передачи данных, адрес url, а также 
версию http. Основные методы GET -для получения данных, POST - для отправки
данных, DELETE - для удаления, и PUT - для замещения данных.
2. Заголовки запроса (message headers) - описывают тело сообщения и передают информацию.
Передаются в виде "имя: значение". 
3. Тело запроса (entity body) - сами данные, которые передаются.

Данные проходят сложный и длинный путь, пока поступят на сервер.
https - это расширение для обычного http, которое реализует упаковку данных в 
криптографический протокол. Расшифровывается как Hyper Text Transfer Protocol Secure.
Поддерживается всеми современными браузерами и обеспеивает приемлемый уровень защиты.
*/

Коды ответов http
/*Информационные 100-199
Успешные 200-299
Перенаправления 300-399
Ошибки на клиенте 400-499
Серверные ошибки 500-599
*/

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

XMLHttpRequest(XHR)
/*Разработан Microsoft еще в конце 90-ых. Позволяет делать быстрые запросы на сервер.
XML в названии - просто рудимент или дань прошлому. Сейчас этот метод работает
с любыми данными. Метод встроен в бразуер.

Есть более новый метод fetch(), но XML используется по трем причинам:
-Чуть больше функциональность (например отслеживание прогресса отправки данных)
-Есть много старого кода на XMLHttpRequest
-Старые браузеры не поддерживают fetch()

Имеет два варианта работы - асинхронный и синхронный. Асинхронный используется почти всегда.
Для синхронности нужно задать false для необязательного аттрибута async, который по
умолчанию задан как true.
xhr.open('method', '/url', false);
Синхронный запрос может сильно затормозить браузер, так что имеет смысл пропустить его.

Итак, начинать работу с XMLHttpRequest нужно с его создания.*/
let xhr = new XMLHttpRequest()

//Далее инициализируем запрос
xhr.open(method, url, [async, user, password])
//user, password - для базовой авторизации, если требуется.

//Теперь отправим запрос
xhr.send([body])
//Body - необязательный параметр, нужен чтобы передать данные при POST и PUT
//Метод достаточно всеяден, но лучше в виде строки.

//Далее метод может слушать ответ. Три самых частых события - load, error, progress
xhr.onload = function() {
  alert(`Загружено: ${xhr.status} ${xhr.response}`)
}

xhr.onerror = function() { //если вообще не получилось отправить
  alert(`Ошибка соединения`)
}

xhr.onprogress = function(event) { //работает при загрузке ответа с сервера
	alert(`Получено ${event.loaded} байт`)
	//здесь доступна работа с автоматически генерируемым event:
	// event.loaded - количество загруженных байт
	// event.lengthComputable = равно true, если сервер присылает заголовок Content-Length
	// event.total - количество байт всего (только если lengthComputable равно true)
}

//После получения ответа с сервера мы можем обратиться к нему через свойства:
xhr.status //код сообщения от сервера (404)
xhr.statusText //тескт сообщения от сервера (не найдено)
xhr.response //тело ответа

//Если мы хотим прервать запрос, то используется:
xhr.abort()


Отлов ошибок
//xhr.onerror отлавливает лишь глобальные ошибки в работе запроса,
//например, если был указан неверный url.
//Но ошибка может произойти на сервере, и нам вернется ответ, но с другими данными.
//В этом случае xhr.onerror будет думать, что все в порядке.
//Для отлова можно также проверить:
if (xhr.status >= 400) ...
//Так как после 400 идут коды сетевых и серверных ошибок, то мы отловим их все.


Тип ответа xhr.responseType()
//Свойство xhr.responseType используется, чтобы указать ожидаемый тип ответа:
//По умолчанию это строка.
"text"// строка,
"document"// XML-документ (может использовать XPath и другие XML-методы),
"json"// JSON (парсится автоматически).
//Устанавливается желаемый тип ответа до отправки запроса (до send).


HTTP-заголовки
/*К запросу можно добавлять заголовки при помощи
setRequestHeader(name, value)*/
xhr.setRequestHeader('Content-Type', 'application/json')

/*Повторные добавления загловков с тем же name лишь добавляют к этому имени новой value.
Некоторые заголовки управляются исключительно браузером, например Referer или Host, 
а также ряд других. 
XMLHttpRequest не разрешено изменять их ради безопасности пользователей 
и для обеспечения корректности HTTP-запроса.

Каждый заголовок всегда начинается с новой строки, они разделены символами "\r\n"*/


//Полный пример XMLHttpRequest()
const requestURL = 'https://jsonplaceholder.typicode.com/users/'

function sendRequest (method, url, body = null) {
	return new Promise ((resolve, reject) => {
		let xhr = new XMLHttpRequest()

		xhr.open(method, url)

		xhr.responseType = 'json'
		xhr.setRequestHeader('Content-Type', 'application/json')
		//определяем тип передаваемых данных при методе POST

		xhr.onload = () => {
			if (xhr.status >= 400) {
				reject(xhr.response)
			} else {
				resolve(xhr.response)
			}
		}

		xhr.onerror = () => {
			reject(xhr.response)
		}

		xhr.send(JSON.stringify(body))
		//преобразуем наш объект в строку JSON при методе POST
	})
}

//Теперь отправим запрос GET
sendRequest('GET', requestURL)
	.then(data => console.log(data))
	.catch(err => console.error(err))


//И запрос POST
var user = {
	name: 'Uriy',
	surname: 'Korotovskikh',
	age: 24
}

sendRequest('POST', requestURL, user)
	.then(data => console.log(data))
	.catch(err => console.error(err))

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

fetch()
/*Более современный и мощный метод, но поддерживается еще не всеми браузерами.
fetch() - это промис.*/
let promise = fetch(url, [options])
//options - метод, заголовки.
//Причем без второго параметра по умолчанию выполняется метод GET.

//Собственно, так как это промис, используется с await либо в async function
//Промис fetch возвращает объект response.
let response = await fetch(url)

//Response - это объект, который мы получаем, он содержит в себе несколько свойств.
response.status //Код сообщения от сервера.
response.ok //true(если код HTTP-статуса в диапазоне 200-299) или false(если произошла ошибка)
response.headers // похожий на Map объект с HTTP-заголовками


//Для получения тела ответа нужно вызвать дополнительный метод:
response.text()// читает ответ и возвращает как обычный текст
response.json()// декодирует ответ в формате JSON (этот метод - промис)
response.formData()// возвращает ответ как объект FormData (разберём его в следующей главе)
response.blob()// возвращает объект как Blob (бинарные данные с типом)
response.arrayBuffer()// возвращает ответ как ArrayBuffer 
//(низкоуровневое представление бинарных данных)

//Для получения ответа можно выбрать лишь один метод за один запрос.
//Либо текст либо JSON.

//Собственно, на этом заканчивается основа fetch()
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
//Для базового запроса этого достаточно.
//Также можно переписать данную запись через методы промисов:
fetch(url, options)
	.then(response => response.json())
	.then(result => ...)


response.headers (заголовки ответа)
//Заголовки ответа задаются в похожем на Map объекте response.headers.
//С ним можно взаимодействовать при помощи методов карты.
response.headers.get('Content-Type')
for (let [key, value] of response.headers) {
	console.log(`${key} = ${value}`);
}

headers (заголовки запроса)
//Заголовки запроса задаются в options при вызове fetch.
let response = fetch(url, {
	headers: {
		Authentication: 'secret'
	}
})
//Есть список запрещенных заголовков, которые мы не можем устанавливать,
//Это делает исключительно браузер.


POST-запросы с fetch()
//Для формирования такого запроса также используем options.
fetch (url, {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json;charset=utf-8'
	},
	body: JSON.stringify(obj)
});
//Данные можно отправлять в следующих форматах:
//Строка (в т.ч. JSON), FormData, бинарные данные (Blob/BufferSource).


//Прервать выполнение запроса fetch() можно при помощи встроенного
AbortController()


//Полный пример fetch() GET
function sendRequest(method, url, body = null) {

	return fetch(url)
	.then(response => {
		if (response.ok) {
			return response.json()
		}
		return response.json().then(error => {
			const e = new Error(`Something goes wrong!`)
			e.data = error
			throw e
		})
	})
}

let url = 'https://jsonplaceholder.typicode.com/users/'

sendRequest('GET', url)
	.then(data => console.log(data))
	.catch(err => console.error(err))



//Полный пример fetch() POST
function sendRequest(method, url, body = null) {
	const headers = {
		'Content-Type': 'application/json'
	}

	return fetch(url, {
		method: method,
		body: JSON.stringify(body),
		headers: headers
	})
	.then(response => {
		if (response.ok) {
			return response.json()
		}
		return response.json().then(error => {
			const e = new Error(`Something goes wrong!`)
			e.data = error
			throw e
		})
	})
}

let url = 'https://jsonplaceholder.typicode.com/users/'

const body = {
	name: 'Uriy',
	age: 24
}

sendRequest('POST', url, body)
	.then(data => console.log(data))
	.catch(err => console.error(err))

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

JSON
/*Java Script Object Notation.
Это формат представления данных, который изначально появился в JS, но набирает
все большую популярность. Компактен и прост в испоьзовании.

По сути JSON - это обычная строка. Но она может конвертироваться в объект.
Внешне JSON похож на стандартный объект, но есть небольшие отличия (кроме того что он -строка).
Все ключи заключаются в двойные кавычки.
Поддерживаются только двойные кавычки, так что обычные и обратные будут преобразованы в них.

JSON поддерживает следующие типы данных:
Массив, объект, строки, числа, логические значения, null.

Значение ключа (value) не может быть функцией или датой.
JSON запишет их просто как строковый материал.

При работе с JSON и преобразования в/из строки в JS используются методы
JSON.stringify и JSON.parse().
Эти методы очень актуальны в сетевых запросах, так как в http данные передаются в виде строки.*/

JSON.stringify(target, [replacer, space]) //преобразует объект в строку
//target - объект или примитив, который мы переводим в JSON.
//replacer - используется, если мы хотим заменить опр. элементы при конвертации.
//space - определяет сколько пробелов будут в отступе по таблуяции.
JSON.stringify(1) //1
JSON.stringify('test') //"test"
JSON.stringify(true) //true

toJSON()
//JSON.stringify вызывает метод toJSON() если он встроен. Но также его можно
//перезадать, определив таким образом, как объект будет конвертироваться в JSON.


JSON.parse(str, [reviver]) //преобразует строку в формат JSON.
//str - целевая строка
//reviver - функция которая будут вызываться для каждой пары ключ/значение и 
//может изменять их.

//При конвертации строки в JSON важно, чтобы она соответсвовала всем требованиям,
//иначе будут выдаваться ошибки.

//Использование reviver
//Если в строке был передан особый объект, например дата, то при конвертации в JSON
//он не будет создан как объект, а записан как обычная строка.
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}'
let meetup = JSON.parse(str, (key, value) => {
	if (key === 'date') {
		return new Date(value)
	}
	return value
})
//Теперь будет записан объект дата, а не обычная строка.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

FormData
/*Это объект, передающий данные HTML-формы.
Создается с помощью конструктора.*/
let formData = new FormData([form])


/*Пример с отправкой формы
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>
*/
formElem.onsubmit = async (e) => {
	e.preventDefault();

	let response = await fetch('/article/formdata/post/user', {
	  method: 'POST',
	  body: new FormData(formElem)
	})

	let result = await response.json()
}


/*Объекты FormData всегда отсылаются с заголовком Content-Type: form/multipart.
Данный способ кодировки позволяет отправлять файлы.

<input type="file" name="picture" accept="image/...">*/


/*Можно передавать объект из формы, как указано выше. 
Но есть возможность изменяь данные FormData.
У этого объекта есть ряд встроенных методов.*/
FormData.append(name, value) //добавляет поле в объект
//Если поле с этим именем есть, то добавится новое.
FormData.set(name, value) //удаляет все поля с этим именем(если есть) и добавляет новое.
FormData.delete(name) //удаляет свойство.
FormData.has(name) //возвращает true, если свойство есть.
FormData.get(name) //получает свойство.


=====================================================================================================

PROXY

/*Это объект-обертка класса 'proxy' вокруг какого-либо объекта или класса в JS. 
Они делают две основные вещи:
Перехват доступа к свойствам объекта,
Перехват методов проксируемого объекта.
Причем, это работает даже для несуществующих методов и свйоств.

Задается proxy следующим образом*/
let obj = new Object 
obj = {a: 1, b: 2}
const objProxy = new Proxy(obj, handler)
//obj - target, целевой объект 
//handler - набор методов, который мы хотим задать (иначе говоря, ловушек)
//Теперь взаимодействовать мы будем уже с прокси-объектом.
//Но изменения, внесенные в прокси, будут влиять и на объект.

proxy для объектов
//Есть объект Object
let obj = new Object 
obj = {a: 1, b: 2}

//Например, можно реализовать функцию гет, которая будет работать при вызове свойства объекта
const objProxy = new Proxy (obj, {
	get (target, prop) {
		console.log(`Getting ${prop}`)
		return target[prop]
	},


	//Далее установим ловушку на присвоение значения свойству.
	//Причем конструкция if, else делает код более безопасным
	set (target, prop, value) {
		if (prop in target) {
			target[prop] = value
		} else {
			throw new Error (`No ${prop} field in ${target}`)
		}
	},


	//Теперь проверим, есть ли такое поле в объекте
	has (target, prop) {
		return ['a', 'b'].includes(prop)
	}, //вернет true если есть, иначе false


	//Удалим свойство
	deleteProperty (targer, prop) {
		console.log(`Deleting ${prop}`)
		delete target[prop]
	}
})

//Всего для объектов существует 13 методов перехвата, основные представлены выше.

proxy для функций
//Тут присутствует два дополнительных метода перехвата.
//Есть функция
const log = (text) => `Log ${text}`

//Создадим прокси
const fp = new Proxy(log, {
	apply(target, thisArg, args) {
		console.log('Calling fn...')
		//Сейчас мы перехватили вызов функции log, поэтому нужно запустить ее
		return target.apply(thisArg, args).toUpperCase()
		//Фишка в том, что здесь можно что угодно делать с возвращаемым значением,
		//например, перевести все символы в верхний регистр,
		//даже если это не указано в функции.
	}
})


proxy для классов
//У нас есть созданный класс Person
class Person {
	constructor (name, age) {
		this.name = name
		this.age = age
	}
}

//Создадим прокси для этого класса, который будет обрабатывать все его вызовы
//при создании объектов на его основе
const personProxy = new Proxy(Person, {
	//Специальный прокси-метод для отлова создания через конструктор
	construct(target, args) {
		console.log('Constructing...')
		//Раз мы отловили создание, его надо реализовать
		//return new target(...args)
		//Но мы можем сразу обернуть новый объект в прокси
		return new Proxy(new target(...args), {
			//сразу реализуем метод гет в покси на объекте
			get (targ, prop) {
				console.log(`Getting ${prop} prop...`)
				return targ[prop]
			}
		})
	}
})

const p = new personProxy('Yury', 24) //Создаем объект черерз прокси.
//В случае, если в конструкторе выше мы возвращаем прокси, то создается прокси.

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Применение прокси

Example 1.
//Начнем с функции гет, в ней можно реализовать любую логику
//Есть объект obj
const obj = {id: 2, name: 'korotovskikh', surname: 'Yury'}
const op = new Proxy (obj, {
	get (target, prop) {
		//Реализуем любую логику
		if (!(prop in target)) {
			return prop.split('_').map((item) => { return target[item]}).join(' ')
		}
		return target[prop]
	}
})
//В данном примере мы можем динамически задавать набор значений,
//которые хотим получить, разделяя их '_'.


Example 2.
//Реализация доступа к элементу массиву по отрицательному индексу в JS
//в оригинальном JS такой возможности нет. Но решаемо через прокси и метод get
const array = ['a', 'b', 'c']
const ap = new Proxy (array, {
	get (target, propKey) {
		if (Number(propKey) != NaN && Number.isInteger(Number(propKey)) && Number(propKey) < 0) {
			propKey = String(target.length + Number(propKey))
			//сделали propKey строкой, так как индекс массива - это не число, а строка.
		}
		return target[propKey]
	}
})


Example 3.
//Сделаем установку свойства объекта безопасным (валидация)
//Например, чтобы в поле age можно было записать только чило от 1 до 150.
const person = {name: 'Yury', age: 24}
const personPropValidator = new Proxy(person, {
	set(target, property, value) {
		//Проверяем свойство на соответствие условиям
		if (property === 'age') {
			if (!Number.isInteger(value) || (value > 150) || (value < 0)) {
				throw new TypeError ('Please, use the right age.')
			}
		}
		target[property] = value
	}
})


Example 4.
//Ассоциативные свойства
//Когда нужно при задании одного свойства автоматически определять другое.
//Для этого есть таблицы данных

const location2postcode = {
  'JavaScript Street': 232200,
  'Python Street': 234422,
  'Goland Street': 231142
}
const postcode2location = {
  '232200': 'JavaScript Street',
  '234422': 'Python Street',
  '231142': 'Goland Street'
}

//Реализация
//(здесь мы сначала задаем handler, а потом отправляем его в прокси)
//хэндлер:
let postcodeValidate = {
  set(target, property, value) {
	if(property = 'location') {
	  target.postcode = location2postcode[value]
	  
	}
	if(property = 'postcode'){
	  target.location = postcode2location[value]
	}
  }
}

//прокси:
const person = new Proxy ({name: 'Jack'}, postcodeValidate)
//теперь при задании опр. свойства другое сразу же будет дополняться
//из таблицы соответствия.


Example 5.
//Приватные (hidden) свойства
//Нужно сделать так, чтобы извне свойство нельзя было получить.
//Есть объект, и мы хотим сделать приватным свойство _uid
const person = {
	name: 'Yury',
	age: 24,
	_uid: '123123'
}

//Обернем его в прокси
const op = withHiddenProps(person)

function withHiddenProps (target, prefix = '_') {
	return new Proxy(target, {
		has: (obj, prop) => prop in obj && !prop.startsWith(prefix),
		//теперь реализуем скрытие для вызова ключей объекта
		ownKeys: obj => Reflect.ownKeys(obj).filter(p => !p.startsWith(prefix)),
		//теперь нельзя получить
		get: (obj, prop, receiver) => (prop in receiver ? obj[prop] : void 0)
		//receiver это сам прокси
		//prop in receiver взаимодействует с методом ownKeys, убирая свойства с префиксом
	})
}
//Теперь свойство скрыто для внешнего доступа:
//data._uid - undefined
//'_uid' in op - false


Example 6.
//Дефолтное значение для свойства (если оно не задано)
//defaulValue - свойство которое будет выдаваться, если такого нет в объекте.
//Создадим функцию, которая будет оборачивать объект в прокси.
const vithDefaulValue = (target, defaulValue = 0) => {
	return new Proxy (target, {
		get (target, prop) {
			if (prop in object) {
				return object[prop]
			} else {
				return defaultValue
			}
		}
	})
}

//И сам объект, а потом применим к нему функцию
const position = {x: 24, y: 25}
const op = vithDefaulValue(position, 0)


Example 7.
//Оптимизация скрипта.
//Имеем массив из объектов.
const userData = [

	{id: 1, name: 'Alex', job: 'SystemAdmin', age: 24},
	{id: 2, name: 'Andrey', job: 'Physician', age: 24},
	{id: 3, name: 'Evgeniy', job: 'Engeneer', age: 24},
	{id: 4, name: 'Vladimir', job: 'Scientist', age: 24},
	{id: 5, name: 'AlexP', job: 'DataEngeneer', age: 24}

]

//Мы хотим находить пользователя по айди.
console.log(userData.find(user => user.id === 2))
//Эта операция может быть затратна при большем количестве свойств объекта
//и при частом вызове.
//Упрощаем.

const index = {}
userData.forEach(item => index[item.id] = item)
//Благодаря этому мы создаем объект, где ключами являются айдишник, а свойствами -
//объекты из массива.
//Этот метод ляжет в основу дальнейшей реализации.

//Запроксируем класс, в который будет передаваться массив
const IndexedArray = new Proxy (Array, {
	construct(target, [args]) {
		//Создадим в прокси точно такой же index
		const index = {}
		args.forEach(item => index[item.id] = item)

		return new Proxy(new target(...args), {
			get: (arr, prop) => {
				switch (prop) {
					case 'push': return item => {
						index[item.id] = item
						//продублируем функционал
						arr[prop].call(arr, item)
					}
					case 'findById': return id => index[id]
					default: return arr[prop]
				}

			}
		})
	}
})

//Собственно, создаем массив
const users = new IndexedArray([
	{id: 1, name: 'Alex', job: 'SystemAdmin', age: 24},
	{id: 2, name: 'Andrey', job: 'Physician', age: 24},
	{id: 3, name: 'Evgeniy', job: 'Engeneer', age: 24},
	{id: 4, name: 'Vladimir', job: 'Scientist', age: 24},
	{id: 5, name: 'AlexP', job: 'DataEngeneer', age: 24}
	])
//И он сразуоборачивается в прокси.


Reflect
/*Это встроенный объект, который предсотавляет методы для перехватывания
операций. С помощью него можно перенаправлять операцию на исходный объект. 
Example:*/
Target[prop] == Reflect.get(target, prop, receiver)
//Reciever задает контекст выполнения функции гет.


=====================================================================================================

Map, Set, WeakMap, WeakSet

Map
/*Это своеобразный аналог объекта в JS. 
Это коллекция, состоящая из данных ключ - значение.
Основное отличие от объекта в том, что у Map в качестве ключа могут быть
любые типы данных.
Объект приводит значения ключей к строкам, а Map сохраняет их исходный тип данных.
Основные базвые команды Map:*/

new Map() //создает новую колллекцию
map.set(key, value) //записывает в ключ значение value
map.get(key) //возвращает ключ или undefined если его нет
map.has(key) //проверяет есть ли ключ
map.delete(key) //удаляет ключ
map.clear() //полностью очищает коллекцию от элементов
map.size() //возвращает текцщее количество элементов

//В качестве ключа в Map может даже выступать объект
myMap.set({name: John, age: 22}, 12345)
//Присвоит объекту идентифкатор 12345.

//Если же в обычный объект попытаться передать в ключ другой объект, то он
//будет записан как "[object Object]".

//Также в качетсве ключа в Map может выступать даже NaN.

//Каждый вызов map.set() возвращает map, так что мы можем чейнить эти вызовы.
myMap.set('1', 'abc')
	.set(1: 543)
	.set(true: 'false')
//Такой метод записи называется fluent интерфейс.
//Если давать точное определение, то fluent интерфейс - это методика организации кода.


Перебор элементов в Map
/*Стоит отметить, что Map, в отличие от обычных объектов, содержит ключи 
в том порядке, в котором происходило их добавление.
Для перебора существует три основных метода:*/
map.keys() //возвращет итератор по ключам
map.values() //возвращает итератор по занчениям
map.entries() //возвращает итератор по парам [key, value]
//Кстати говоря, object.entries() также возвращает массив пар.

//Все этим способы как правило используются с циклом for of.
for (let key of map.keys()) {
	console.log(key)
}

for (let value of map.values()) {
	console.log(key)
}

for (let [key, value] of map) { //то же, что и map.entries()
	console.log(key, value)
}

//Кроме этого, коллекция имеет встроенный метод forEach, похожий на подобный метод массива
map.forEach((value, key, map) => {
	console.log(`${key}: ${value}`)
})


Создание и преобразование Map
/*Карта создается из массива пар.
[[a, b], [c, d]]
Если мы хотим создать карту из объекта, то потребуется сначала перевесети его в видмассива пар,
а потом уже преобразовать в карту. 
Для этого существует команда Object.entries(obj). Она возвращает массив пар.*/
let map = new Map(Object.entries(obj))

Преобразовать Map в объект
//Из массива пар также можно создать объект, поэтому мы должны сначала получить
//из карты массив пар при помощи команды map.entries().
//И лишь потом создать объект из массива пар при помощи Object.fromEntries()
let obj = Object.fromEntries(map.entries())
//Но даже и это можно скоратить, так как fromEntries может сам перебирать Map
let obj = Object.fromEntries(map)

Преобразовать Map в массив
//гораздо проще. После преобразования будут доступны все методы массивов. Достаточно применить:
Array.from(map)


WeakMap 
/*Особый вид карты, ключевыми особенностями которого являются:
1. В качестве ключей могут быть только объекты.
2. WeakMap имеет слабые ссылки на объекты, так что удалив объект за пределеами WeakMap
(или удалив ссылку на него, что приведет к очищению сборщиком мусора), мы автоматически
удалим объкт и из WeakMap. То есть объект не будет сохранятся в памяти только потому, что он есть
в WeakMap. 
3. У WeakMap нельзя вызвать ключи каким-то методом, также нельзя измерить размер,
иначе это привело бы к индетерминированности.

WeakMap довольно удобна для хранения данных, которые могут быть легко удалены. 
Чтобы не занимать память уже ставшими ненужными данными, их отправляют в WeakMap.
Также она используется для кеширования данных.*/

let cache = new WeakMap();
// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
	let result = /*вычисляем результат для объекта*/ obj;

	cache.set(obj, result);
  }

  return cache.get(obj);
}

let obj = {userName: 'name', userId: 123};
let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен, он автоматически удалиться из cache:
obj = null;

>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>

Set
/*Это так называемое множество. Особенность в том, что в сете каждое значение
может встречаться один лишь раз.
Основные методы сета:*/

new Set(iterable)// создаёт Set, и если в качестве аргумента был предоставлен 
//итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value)// добавляет значение (если оно уже есть, то ничего не делает)
set.delete(value)// удаляет значение
set.has(value)// возвращает true, если значение присутствует в множестве, иначе false.
set.clear()// удаляет все имеющиеся значения.
set.size()// возвращает количество элементов в множестве.

//Кроме этого есть свстроенные методы keys() и values().
//Они выполняют одинаковую функцию в сете, так как там не пары значений.
//То же самое в цикле forEach в качестве первых двух аргументов передается 
//одно и то же value.

//set.entries() возвращает пары дублирующих друг друга значений.

//Для сет работает чейнинг
set.add(value).add(value).add(value)


WeakSet
/*Работает аналогично со слабой картой и имеет схожие особенности.
Он так же имеет слабые свзяи с объектами, не удерживая их в памяти.
Так же может принимать в качестве ключей (и зачений одновременно, так как это сет)
только объекты.
Так же не работают методы size, keys, values.*/


=====================================================================================================

MOBILE INTERFACE

Основные события
/*В целом все работает примерно так же, как и в стандартном интерфейсе.
Существуют специальные события прикосновений к элементу.
Их легко проверить в браузере, переключившись в инструментах разработчика на 
мобильную версию и эмулируя касания.

Основные события:*/
touchstart //момент начала касания
touchmove //собственно свайп
touchend //конец касания или если палец выйдет за край экрана
touchcancel //когда палец вышел за пределы window (expiremental)

//Можно использовать как
element.addEventListener('touchstart', function())
//Или как:
element.ontouchstart = function()
//Если вы используете события касания, вам следует вызывать 
//preventDefault() для предотвращения отправки событий мыши.
//Полный пример соыбтия касания для элемента #box:
let box = document.qurySelector('#box')
box.addEventListener('touchstart', function (event) {
	console.log('You touched me!')
})
//В данном случае генерируется событие TouchEvent, обладающее набором свойств.
//Самые важные из них это
TouchEvent.changedTouches
TouchEvent.targetTouches
TouchEvent.touches
TouchEvent.scale

//changedTouches, targetTouches, touches возвращают массив TouchList со всеми касаниями.
//Каждое касание представлено объектом Touch, который также имеет полезные свойства.
//С их помощью можно, напрмиер, отследить координату касания:
box.addEventListener('touchstart', function (event) {
	console.log(`${event.changedTouches[0].pageX}, ${event.changedTouches[0].pageY}`)
})


//====================================================
//Как остледить длину и направление свайпа по горизонтали.
//Здесь поможет комбинация событий. Скажем, у нас есть некий элемент slider, надо отселдить свайп.
let slider = document.querySelector('#slider')
let start = null
let end = null

function sum (start, end) {
	return Math.abs(start - end)
}

function compare (start, end) {
	if (start > end) {
		return 'Swipe to left'
	} 
	if (start < end) {
		return 'Swipe to right'
	}
}

slider.addEventListener('touchstart', function (event) {
	start = event.changedTouches[0].pageX
})

slider.addEventListener('touchend', function (event) {
	end = event.changedTouches[0].pageX
	if (start !== end) {
		console.log(compare(start, end))
		console.log(sum(start, end))
	} else return
})


=====================================================================================================