Случайное число в JS
<script>
function getRandomInt(max) {
		return Math.floor(Math.random() * Math.floor(max));
}

let number = getRandomInt(100);
</script>

	</script>
	<p></p>
	<input type="button" name="b" value="Click me" onclick="ButtonClick (this)"/>
	<p></p>
	<span style="color: blue" onmouseover="counter1 (this)">На этот текст было наведено 0 раз</span>
	<p></p>
	<!-------------working with forms------------->
	<form action="" method="post" name="test" id="form">
		<label for="name"><big>NAME:</big></label>
		<input type="text" name="name" placeholder="Name" id="1" /><br /><br />
		<label for="email"><big>EMAIL:</big></label>
		<input type="text" name="email" placeholder="Email" id="1" /><br /><br />
		<label for="password" ><big>PASSWORD:</big></label>
		<input type="password" name="password" placeholder="Password" id="2" /><br /><br />
		<label for="repassword" ><big>REWIEW:</big></label>
		<input type="password" name="repassword" placeholder="Password" id="3" /><br /><br />
		<span><big>GENDER:</big></span>
		<input type="radio" name="state" id="4" value="Man"/><label style="color: blue">MAN</label>
		<input type="radio" name="state" id="5" value="Woman"/><label style="color: red">WOMAN</label><br /><br />
		<input type="button" onclick="valid(document.getElementById('form'))" name="submit" id="6" value="SEND"/><br /><br />
	</form>
	<p></p>
	Времени прошло: <span id="countt">-1</span>
	<!-------------------timers------------------->
	<script type="text/javascript">
		//var id = setInterval("myFunc_1()", 1000);//1 sec = 1000 milisec
		var counter = 0;

		function myFunc_1 (){
			alert("Seconds passed - " + counter);
			counter++;
			if (counter == 3) clearInterval(id);
		}
		var counterr = 0;
		function timer (){
			counterr++;
			document.getElementById("countt").innerHTML = counterr;
			setTimeout("timer()", 1000);
		}
		timer();
		document.write("<br />");
		document.write("<br />");

		var text = "Number Pi" + Math.PI;
		text += "\nNumber E" + Math.E;
		text += "\nModule" + Math.abs(-5);
		//Math.sin Math.random()
		//Math.floor() Math.ceil()
		//math.floor(Math.random()*11)-от 0 до 10; 
		//alert(text);
		// var date = new Date();
		// date.setMonth(1);
		// var textt = "Year" + " - " + date.getFullYear();
		// textt += "\nMonth" + " - " + date.getMonth();
		// textt += "\nDay" + " - " + date.getDate();
		// textt += "\nHour" + " - " + date.getHours();
		// alert(textt);

		var arr = new Array (11, 22, 34, 54, 46, 455, 17);
		text = "Array length is " + arr.length;
		text += "\nArray has: " + arr.join(", ");
		text += "\nArray has: " + (arr.sort()).join(", ");
		alert(text);

		var string = "Little string";
		text = string.length;
		text += "\n " + string.toUpperCase();
		text += "\n " + string.toLowerCase();
		text += "\n " + string.substring(1, 5);
		text += "\n " + string.charAt(3);
		text += "\n " + string.indexOf("str");
		alert(text);

		console.log (num);
		document.write ("Result is", num + num1);
		var arr = [1, 2, 3];
		var arr = new Array (1, 2, 3);
		arr [3] = 4;
		


		

	</script>

DOM (HTML)
(head body)
childNodes
firstChild
lastChild
nextSibling
previousSibling

Attributes of elements:
tagName (BODY)
style (width: , color:)
innerHTML (document.getElementById('footer').innerHTML = '<h1>Bye!</h1> <p>See ya</p>')
class (class = "") Для оформления
onclick, onkeypress, onfocus 

--------------------------------------------------------------------------------------------------------
ОСНОВЫ ООП

Принципы:

Абстракция — отделение концепции от ее экземпляра. Это использование только необходимых характеристик объекта, без потери его основных свойств. Абстракция данных - это предоставление "миру" только необходимых данных, и скрытие фоновой информации;

Полиморфизм — реализация задач одной и той же идеи разными способами. Один и тот же код может работать с разными типами данных. Обобщенное программирование - код, который можно применять к разным типам данных, не меняя его при этом. Есть языки программирования с разными типизациями.
Языки в целом бывают типизированные (Python, C, JS, Java) и нетипизированные (ассемблер)
Типизированные делятся на несколько пересекающихся категорий.
Тип типизации - на статическую типизацию, где конечные типы устанавливаются уже на этапе компиляции(C, C#, Java) и динамическую типизацию (JS, Python). 
Сильная/слабая - сильная не позволяет смешивать данные в одной операции, например вычитать из строки число (Java, Python) и слабая допускает операции с разными данными (C, JS).
Явная или неявная. Явная при объявлении переменной требует указывать ее тип (C++, C#), неявная перекладывает задачу определения типа на компилятор (JS, PHP);

Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;

Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.


--------------------------------------------------------------------------------------------------------

OBFUSCATION AND OBFUSCATORS!

--------------------------------------------------------------------------------------------------------
ЦИКЛЫ

Типы циклов в JavaScript:
for
while (do while -выполнится как минимум один раз)
for in
for of (array)

Loops in JS: for, while, do/while, 
<Script>
for (var prop in obj) {
	console.log("obj." + prop + " = " + obj[prop]); //для работы с объектами
for (const value of iterable) {
	console.log(value); //для перебирания массивов и строк (char)


for (let char of "test") //- перебирает по очереди все элементы строки.
str.charCodeAt(index) //- выдает значения юникода для элемента строки под номером index.
</Script>

--------------------------------------------------------------------------------------------------------

parseInt("8", 10); - 8 сделать из строки число
isNaN(48); 
parseFloat("2.55"); - 2.55 сделать из строки дробь
Number(); для присванивания числовых значений

this - значение зависит от контекста
Просто в коде this ссылается на окно виндоус и выдает его параметры
В объекте this (в методе объекта) ссылается на сам объект, выдает объект со всеми его свойствами. Но есть момент - в стрелочной функции в объекте он выдаст не объект, а то, что было в this на момент создания стрелочной функции. Для работы внутри объектов стрелочные функции мало подходят.

var, let(no redeclare), const(no update, no redeclare)

.MATCH str.match(regexp) str.match(/[aeiou]/gi); - возвращает массив из совпадений(для подсчета гласных напрмиер).

null - определенное отсутствие значение, undefined- неопределенность в значении.
null  == undefined // true
null === undefined // false

Функция это тоже объект. test = function() {alert('Hello!')}

В JavaScript есть 6 базовых типов данных — это Undefined (обозначающий отсутствие значения), Null, Boolean (булев тип), String (строка), Number (число) и Object (объект).
При этом первые 5 являются примитивными типами данных, а Object — нет. Кроме того, условно можно считать, что у типа Object есть «подтипы»: массив (Array), функция (Function), регулярное выражение (RegExp) и другие.

typeof возвращает тип данных. typeof(28) - number;

isArray() - проверяет массив ли это

DOM selectors
    getElementsByTagName()
    getElementsByClassName()
    getElementById()
    querySelector()
    querySelectorAll()

slice - не меняет массив, splice меняет массив. splice(2, 1) - удалит третий элемент массива. splice(2, 2) - удалит тертий и четвертый. splice(2, 0, 55, 55)-добавит после третьего элемента два элемента 55.

string.split(separator, limit); - преобразует строку в массив, разделяя ее по элементам. separator-чем разделять, лимит-до какого символа. Если указать str.split("") - то вернет массив из всех символов, разделенных запятой.

JS это динамический язык, так как у переменных нет фиксированного типа данных, их можно свободно переназначать. Это называется динамиеская типизация.

callback-функции - это как бы функция в функции, мы передаем код из одной функции в другую.

default function parameters - то, что задается в параметрах функции, значения переменных.

ES-6 это стандарт языка. Главное в ес-6 это типы переменных const, let, стрелочные функции, которые выглядят так:
const myFunc=name=>{
	return 'Hi, ${name}'
}
or
const myFunc=name=>'Hi, ${name}';

Promises. Js это однопоточный язык программирования, поэтому чтобы одновременно получить нечто с сервера надо использовать промисы. 
const promise = new Promise((resolve, reject) => {
    ...
  }

Метод .call func.call( obj, parameters ); позволяет вызвать функцию как метод объекта, при этом this наследует объект.

Создание элементов HTML при помощи JS: innerHTML

JSON: (работает не только с JS)
var json = JSON.stringify(our object); -превращение объекта в строку джейсона
var newJsObj = JSON.parse(json); - превращение строки джейсона обратно в объект

XML is worse than JSON

HTML <template></template> - шаблон хтмл, который сразу не видно, но который можно легко заполнить через JS.

Создание нового элемента HTML
let div = document.createElement('div');
div.className = "class";
div.innerHTML = "<p>Всем привет!</p> Вы прочитали важное сообщение.";
Теперь его надо поместить в документ:
document.body.append(div);
Либо вставляет как текст:
ol.prepend(div);
ol.append(div);
ol.before(div);
ol.after(div);
Либо вставляет как хтмл:
div.insertAdjacentHTML('beforebegin', '<p>Привет</p>'); Также можно afterbegin, beforeend, afterend
ol.insertAdjacentHTML(*, html) =>
example: document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
    <strong>Всем привет!</strong> Вы прочитали важное сообщение.
  </div>`);
To delete:---------------------
div.remove()
TO replace:---------------------
second.after(first); - меняет по айдишникам.
To clone:----------------------
let div2 = div.cloneNode(true);-clones with childs
let div2 = div.cloneNode(false);-clones without child

querySelector() - Ищет соответствующие элементы в документе. 
var el = document.querySelector(".myclass"); - ищет по классу элемента
var el = document.querySelector("div.user-panel.main input[name=login]"); - В данном примере возвращается элемент <input name="login"/>, находящийся в <div class="user-panel main">
let div = document.querySelector('#Two'); - поиск по айди

СТРЕЛОЧНЫЕ ФУНКЦИИ =>
<script type="text/javascript">
	let a = (d, c) => {
		//
		//
		//
		return x;
	}

	let a = c => { //когда один параметр в функции
		//
		//
		return y;
	}

	let a = (d,c) => d*c //когда всего одно действие в функции
</script>

CALLBACK ФУНКЦИИ. Джэс это асинхронный язык. Ему безразлична последовательность кода касательно функций. Он пытается запустить все функции одновременно. Если первая функция очень большая, а вторая мелкая, то вторая выполнится быстрее первой. Если первая грузила данные с сервера, а вторая юзает их, то не отобразиться ничего.
Поэтому делаем одну функцию аргументом другой.
<script type="text/javascript">
	function first(y){
		console.log(1);
		y(); //если тут несколько функций то они тоже запустятся одновременно
	}

	function second(){
		console.log(2);
	}

	first(second); //собственно сам колбэк

//если second это функция с двумя аргументами

	function second(a, b){
		console.log(a*b);
	}

	//first(second(5,7)); не работает, так как ломает последовательность выполнения кода.

	first(function(){
		second(5,7);  //используем анониную функцию-обертку, все работает
	});
</script>

Сортировка числового массива:
<script>

	function sortfunction(a, b){
  		return (a — b)
	}

	var myarray=[25, 8, 7, 41]
	myarray.sort(function(a,b){ 
  		return (a — b);
	});
	console.log(myarray); //в метод сорт вставляем анонимную функцию, которая возваращет a - b, для обратной сортировки используем b - a

	let num = [10,9,7,11,456];
	num.sort((a, b) => a - b);
	console.log(num);        //стрелочный вид

	//оптимизированная сотрировка пузырьком, тут мы вдобавок проверяем, провелось ли ействие. если за всю сортировку их не было, то нет смысла сортировать дальше и можно закончить цикл.
	function bubbleSort(arr) {    
		for (var i = 0, endI = arr.length - 1; i < endI; i++) {
       		var wasSwap = false; 

         	for (var j = 0, endJ = endI - i; j < endJ; j++) {
            	if (arr[j] > arr[j + 1]) {
                	var swap = arr[j];

                	arr[j] = arr[j + 1];
                	arr[j + 1] = swap;
                	wasSwap = true;
            	}
        	} 

        	if (!wasSwap) break;
    	}  
    	  
    	return arr;
	}
</script>

Прототпное наследование в джава скрипт. Можно сделать наследование от одного объекта к другому. Скажем есть:
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

Если мы установим прототипное наследование от кролика к животному, то
rabbit.__proto__ = animal;
Теперь у него свиду также нет свойства eats. Но если мы вызовем alert( rabbit.eats );, то браузер пойдет искать его в прототипе и выведет eats: true.


setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
<script type="text/javascript">
	function sayHi() {
  	alert('Привет');
	}

	let timerId = setTimeout(sayHi, 1000); // 1000ms = 1 second, you can use it without let timerId
	// to stop timer use clearTimeout(timerId);

	//to set interval:
	let timerId = setInterval(sayHi, 2000); //to stop clearInterval(timerId);
</script>

Регулярные выражения 
let re = /,|!|\.|\:|\;|\?|\[|\]|/g; 

Поиск элемента в массиве:
array.find()
let array = [1,2,3,-2,-5,4,8];
		let a = array.find( function checkNumber( currentValue ) {
    		return currentValue = 2;} 
		);
console.log(a); сама по себе функция вернет 2, если совпадений нет, то вернет undefined.

-------------------------------------------------------------------------------------------------------

«Плохие программисты думают о коде. Хорошие программисты думают о структурах данных и их взаимосвязях» Линус Торвальдс

-------------------------------------------------------------------------------------------------------

Рекурсия:
<sctript type="text/javascript">
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
</sctript>
Рекурсия хранит в памяти все контексты выполнения, в конце считывает их все из стека. Рекурсия на 100000 уже не работает.

Array.isArray() returns true if object is an array.

.forEach - перебирает по очереди все элементы массива. ДЛя каждого элемента он вызывает функцию. Этой функции он передаёт три параметра callback(item, i, arr)
array.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});

Array.map() .map - возвращает новый массив, состоящий из результатов вызова функции для каждого из элементов:
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
  return name.length;
});
// получили массив с длинами
alert( nameLengths ); // 4,3,10

Array.reduce() .reduce Используется для вычисления единого значения на основе массива. Он сохраняет промежуточный результат. Его аргументы callback-функция(previousValue, currentItem, index, arr), далее можно установить initialValue = 

var arr = [1, 2, 3, 4, 5]
// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0); //0-initialValue
alert( result ); // 15

СВЯЗНЫЙ СПИСОК
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
ИЛИ
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

ДЕБАГЕР JS
В зоне Resources (Ресурсы) показаны файлы HTML, JavaScript, CSS, включая изображения, используемые на странице. Здесь также могут быть файлы различных расширений Chrome.
Зона Source показывает исходный код.
Наконец, зона Information and control (Сведения и контроль) отведена для отладки.

Array.filter .filter - похож на метод мап. Но тут в новый массив попадают элементы не после действия, а после сравнения. Запись:
var numbers = [1, 2, 3, -2, -5, 8, -25];
var positive = numbers.filter(function(x) {
  return x > 0;
});
// получили массив из чисел больше нуля.
alert( positive ); // [1,2,3,8]
Можно работать и с индексами:
var numbers = [1, 2, 3, -2, -5, 8, -25];
var positive = numbers.filter(function(x, index) {
  return index = 1;
});
// получили массив из числа с индексом 1.
alert( positive ); // [2].

.every .some// служат для проверки элементов на условия, возвращают правду или ложь.
var numbers = [1, 2, 3, -2, -5, 8, -25];
Array.every(function(x)){
	return x<5;
}     // .every вернет true если все элементы соответствуют условию, иначе ложь. .some вернет тру если хотя бы один из элементов соответствует.

------------------------------------------------------------------------------------------------------
REST И SPREAD

Аргументы функции это массив arguments, который существует внутри функции. С ними можно работать и вызывать их. arguments[0]=haha; по идее нулевым аргументом будет то значение которое мы первым передаем в функцию. function(a);
Аргументов у функции может быть очень много, например. если это math.max(). Также минус в том, что у стрелочных функций нет arguments. И в том, что это не реальный массив, а его подобие. С ним нельзя работать методами массива. 
В ES6 появилсь остаточные параметры у функций. Аргумент rest ...
function doSomething(first, second, ...rest) - первые два можно выхзвать как обычно.
console.log(first); // Первый аргумент
console.log(second); // Второй аргумент
console.log(rest[0]); // Третий аргумент

Rest хорош тем, что это реальный массив, и он есть у стрелочных функций.
Есть также spread. В отлчии от рест, он наоборот делит массив или строку на аргументы.
doSomething(...args);
// то же самое
doSomething(myArray[0], myArray[1], myArray[2]);
SPREAD часто используется вместо apply. myFunction.apply(null, args) = myFunction(...args)
В args передается массив.
-------------------------------------------------------------------------------------------------------

Объекты
Обращение к свойству объекта:
console.log(object.key);
console.log(object['key']);
let key in object - переменная принимает вид тру если такой элемент есть. нужно для поиска элементов.
let key = object.hasOwnProperty('key'); the same
метод - функция в объекте
delete.object.key;

Присвоение объекта по ссылке:
Если просто присвоить один объект другому, то они будут меняться вместе:
let a ={c:55};
let b = a;
Для того чтобы создать независимого клона объекта Б надо:
let a ={c:55};
let b = {};
for (let key in a){
	b[key]=a[key];
}
При создании конструктором такого не происходит, каждый объект индивидуален:
class Test {
	constructor(a){
		this.c = a;
	}
}
Let MyObject = Test(6);

Array.reverse() .reverse() Возвращает массив наоборот

Array.keys() - возвращает итератор массива. Итерируемый объект - тот, который можно перебрать в цикле. Итератор - структура данных, которая позволяет работать с определенным рядом данных присвоив ему индексы. Object.keys(your_object) возвращает массив из ключей объекта. 

Array.includes - проверяет есть ли элемент в массиве. ! можно проверить что элемента в массиве нет.

<< >> побитовые сдвиги. Сдвигают биты в переменной влево или вправо на указанное число.

Object.freeze() - замораживает свойство объекта и запрещает менять это свойство. 
Let d = Object.freeze({'d': 33});

'use strict' весь сценарий работает в современном режиме, в прицнипе это всегда желательно писать. Но если используются классы или модули, то они автоматически включают его.

------------------------------------------------------------------------------------------------------

`` строки-шаблоны. Позволяют делать перенос строки. 
let str = `обратные кавычки`;
Также позволяет использовать выражения с переменными и переменные alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5

------------------------------------------------------------------------------------------------------

requre('') - подключает определенный пакет

throw - во время функции создает особенное событие

.join - Array.join(separator) -Создает строку из массива, вставляя между элементами separator, напрмиер ", ".

event.stopPropagation() - останавливает дальнейшее всплытие событий. Текущая функция, например .onclick выполнится, но следующие, к которым привязан тот же элемент, покоторому кликнули, не сработают.

.class document.querySelector('.class') - так привязывают к классу.

Array.shift() - удаляет элемент, сдвигае массив влево (2ой станет первым)

Замыкание функции в JS: функция получает свое лексическое окружение изнутри наружу. каждый новый вызов функции - новое лексическое окружение. Если поменялась переменная, то функция будет работать с новым значением. Если переменная изменялась внтури функции (внутри своей области видимости), то при вызове этой функции из другого места, переменная примет начальное значение. Вобщем, функция может получить доступ к лююой переменной, но будет брать ее значение, двигаясь изнутри наружу лексического окружения. Для каждой функции при ее создании создается [[Environment]]. 
Сейчас в JS используются блоки кода. {} просто код заключается в такие скобки и для него создается свое собственое лексическое окружение. Это нужно когда над кодом работают разные прогеры. Чтобы переменные не перепутались.

----------------------------------------------------------------------------------------------------

Сортировка массива нужна, чтобы в нем можно было удобно искать! Это как стопка документов.

----------------------------------------------------------------------------------------------------

.replace(a,b) -заменит а на б
str.replace('яблоки', 'апельсины');
str.replace(/xmas/i, 'Christmas'); - заменит ксмас на кристмас ... флаг i в регулярном выражении позволяет игнорировать регистр

----------------------------------------------------------------------------------------------------

Динамическое программирование - это решение сложной задачи разбиением на простые. Плюс в ускорении алгоритма.

----------------------------------------------------------------------------------------------------

fetch('url') - нужен для получения данных с сервера по ссылке. Это промис, так что с ним можно работать через .then. Возвращает объект response. Можно вызвать response.text() или response.json(). 
Promises .then .catch .finally all, race.

----------------------------------------------------------------------------------------------------

.prototype позволяет присвоить объекту наследование.
X.prototype = y; присваивает при создании объекта через функцию X свойство Y.

У каждой функции уже есть свойсвто протитип.
function Rabbit() {}
Rabbit.prototype = { constructor: Rabbit };
Всем созданным через этот конструктор объектам также будет доступно это свойство:
let rabbit = new Rabbit();
rabbit.constructor = Rabbit; у rabbit есть свойство prototype {constructor : Rabbit}. 
Если переписать свойство prototype, то конструктор уже нельзя будет вызвать, поэтому надо просто добавлять к нему другие свойства.

СВойство constructor нужно чтобы вызывать функцию-конструктора объекта.
Можно создать новый объект просто через:
Let newObj = new oldObj.constructor.
У каждого объекта есть __proto__. Если мы вызываем свойство, то оно сначала ищется в самом объекте, а потом в его прототипе.
Object - самый глобальный класс. Можно записать все что угодно в Object.prototype и тогда для любого объекта в документе можно будет вызвать эту функцию.

У объекта также есть метод Object.create(прототип для нового объекта). Например:
let person = {x : y};
Object.create(person);

__proto__ это объект общий для всех однотипных объектов. У всех чисел он одинковый. То же и для функций итп.
На самом деле лубой объект создается через конструктор, даже число или строка. Просто обычно он невидимы и работают в браузере незаметно. 
Class создается как new Function
-----У любого объекта есть свойство __proto__
__proto__ ссылается на .prototype того конструктора, через который он был создан. .prototype есть только у конструкторов.
let man = 'Ivan' // new String
man.__proto__ = String.prototype

this - ссылается на контекст вызова функции. КОнтекст это то, что слева от точки. Object.function - здесь контекст - это объект. Контекст можно задавать при помощи bind(): function.bind(object). call() работает аналогично, но он сразу запускает функцию.
Часто просто в прототип загоняется функция и с помощью this через нее можно работать с любым объектом через прототип. Например: Array.prototype.func : function() {console.log(this)} Вызываем array.func()
У стрелочных функций нет this

apply((this, [argsArray]) - работает как call, но аргументы передаются в массиве. первый аргумент - this.

----------------------------------------------------------------------------------------------------

Собеседование:
Типы данных. String, number, boolean, null, undefined, object, symbol(not a part of the string)
false = '', 0, null, undefined, false, NaN
[], {}, function - true
Строка преобладает над числом при конвертации, если + 'string' + 5 = string5
При минусе, умножении, делении наоборот, пытается преборазовать строку в число. Не получилось - NaN.
Однако:
'5' + 6 + 4 = '564'
null + 2 = 2
undefined + 2 = NaN
== пытается привести типы к одному, === без приведения.
Функция, которая ничего не возвращает через return, по умолчанию возвращает undefined.

Значения и ссылки. Для примитивов работеат, при объектах лишь ссылки на них. Чтобы скопировать объект, нужно let b = a.concat();

Области видимости

Hoisting. Работает лишь для var. Работа интерпретатора.
Function Expression let variable = function() {}; Эта будет работать только после ее декларации
Function Declaration function count () {}; Можно вызвать из любого места кода.

Let и const

Closures JS / Замыкания
Когда функция имеет доступ к переменным из внешней области видимости.
function sayHello (name){
	const message = 'Hello' + name;
	return function (){
		console.log(message);
	}
}
Замыкаем: let callIgor = sayHello('Igor');
callIgor();
Если функция объявлена внутри блока, например в if, то за его пределами ее вызов будет ошибкой.
Замыкание для sum(5)(4):
function sum(a){
	return function(b){
		return a + b;
	}
}

Immediate Invoked Function Expression IIFE
(function(){})(); вызывается моментально.

Асинхронность JS. Event Loop. 
first();
setTimeout(second, 0):
third;
С таймаутом функция отправляется сначала в WebAPI и лишь оттуда в стек вызовов. Обычные же функции сразу же попадают в стек вызовов.

Loops (for, while ect) can be stopped by two comands:
continue - прерывает текущую итерацию и переходит к следюущей
break - прерывает весь цикл

----------------------------------------------------------------------------------------------------

Получение элементов со страницы
GetElement - возвращает элемент, GetElements - возварщает массив из всех подходящих
GetElementsByID()
GetElementsByClassName()
GetElementsByTagName()
querySelector()- наиболее универсальный, можнов стваить что угодно, выберет 1 элемент.
querySelectorAll() - возвартит массив из всех подходящих
Все универсальнее:
querySelector(.class a)- как и в CSS работает. Данная команда найдет все тэги "a" в элементе с классом .class
querySelector(.class a).getAttribute('id') - так мы можем получить аттрибут элемента.
querySelector(.class a).setAttribute("attribute", new value) - поменять значение аттрибута, к примеру:
querySelector(.class a).setAttribute("href", https/...) - меняет значение ссылки.

Работа с классами:
let element = querySelector()...
element.classList.add('new class');
element.classList.add('first class', 'second class'); - добавляет сразу несколько классов
element.classList.remove('new class');
element.classList.toggle('class'); - переключатель, добавляет класс, если его нети, и убирает, если он есть.

elem.innerHTML - меняет внутри элемента структуру, вычисляется как HTML, работает дольше
elem.textContent - меняет только текст внутри элемента, работает лишь для текста, не тегов.
elem.firstChild.nodeValue - то же, что и текст-контент.

form.onsubmit = function() - интересное для работы с формами. Хоть сабмит это отдельная кнопка, но подключаем мы функцию к самой форме.

evt и preventDefault()
evt - сокращенно event. Это невидимый объект, когторый JS создает при запуске события. У него есть свои методы, например preventDefault() - отменяет стандартное действие события. К примеру:
<script>
form.onsubmit = function(evt) {
	evt.preventDefault();
	console.log('Форма отправлена!');
</script>
Выведет строку в консоль вместо действия отправки данных формы.

; в JS нужна только в конце тех строк, за которыми идут выражения в скобках.

----------------------------------------------------------------------------------------------------

Src async defer - аттрибуты скриптов. Они позволяет загружаться странце (ХТМЛ) отдельно, а сами грузятся отдельно. Разница в том, что defer всетаки сохраняет порядок загрузки в документе, а также он выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded.

----------------------------------------------------------------------------------------------------
НЕМНОГО ТЕОРИИ АСИНХРОННОСТЬ
JS это однопотчный яп. Однопоточный значит - имеет стэк вызовов.
Синхронность - означает, что пока выполняется первая строка, вторая не будет выполнена.

При синхронном выполнении JS закидывается в стек, выполняется, достается оттуда и только потом туда закидывается следующая строка(команда)
При выполнении функции в функции (например, рекурсия), стек вызовов наполняется ими, пока не дойдет до последней вложенной. Далее все начинает раскурчиваться обратно.

Асинхронность - первая строка запускается в фоновом режиме, позволяя второй не дожидаться ее окончания.
Самый наглядный пример на JS это setTimeout()
<script>
console.log(1)
setTimeout(() => {
	console.log(2)
}, 2000)
console.log(3)
</script>
Выведет 1,3,2. setTimeout попадая в стек вызовов, уходит из него невыполненным, уступая место 3. А затем возвращается обратно (через 2 секунды) и выполняется. Куда ходил таймер? Тут вступают в игру Web Api и Event Loop. 
Когда setTimeout попадает в очередь запросов, он не выполняется, а перемещается оттуда в Web API. Там он ожидает указанное время. В это время стек пустой, и туда попадют другие строки кода. По прошествии 2 секунд он должен отправиться в стек. Но у Web API нет права закидывать что-либо напрямую в стек, так что он отправит setTimeout в очередь задач. Event Loop (цикл событий) добавляет первое событие в списке в стек, когда стек пустой. У нас одно событие, так что оно сразу попадет в стек и выполнится.

Pyramid of Doom или CallBack Hell - это огромное количество колл-бэков, включенных друг в друга. Чтобы такого не было, есть промисы(см. далее).

Async и Await -функции.
Это синтаксический сахар для удобства. Можно и на промисах то же самое делать.

Async перед функцией означает, что она вернет промис. Промис с результатом, который мы передаем в ретурн. Фактически с тем же успехом можно вернуть функцией промис return new Promise. 
Await используется ТОЛЬКО внутри Async (возвращающих промис) функций. По факту это эквивалент метода промисов then. Он также не мешает коду выполняться дальше, ожидая заврешения промиса. 
Если есть желание использовать await на верхнем уровне вложенности, то достаточно просто обернуть ее в анонимную стрелочную async функцию.
Пример:
<script>
(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();
</script>
Если промис, которого ждет await закончится с ошибкой (reject), то автоматически будет выброшено исключение, как при throw. Его можно отлавливать через блок try-catch. Блоком try можно охватить неограниченное количество промисов, и все ошибки отловит catch.

.then == await promise
Пример:
<script>
async function f() {
	let promise = new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('Ready!')
		}, 1000);
	});
	let result = await promise; //несмотря на то, что идет сразу же за промисом, ждет его выполнения, пропуская вперед остальные действия (но не в  асинхронной функции).
	console.log(result)	
}

f()
console.log('Are you ready?') //выполнится первым, так как функция асинхронна.
</script>

Обычные итераторы не работают с асинхронными командами. Они не будут ждать, когда выполнится функция или промис, так что если нам нужен результат предыдущей итерации для рассчета новой, например при использовании forEach, то получится ошибка. Для асинхронных операций сработает: 
for (item of someArray) {
 await foo();
}
Либо специальные библиотеки.

----------------------------------------------------------------------------------------------------

Promises - упрощают асинхронность. Собственно внутри него пишется асинхронный код. Промис нужен, чтобы соединить создающий и потребляющий участки кода. Чтобы не посылать бесконечно запросы, а дождаться выполнения и сразу же запустить другой код, который зависит от данных первого. При этом промис не мешает запуститься остальной части кода, которая не зависит от него. Также плюс промисов в том, что они могут отлавливать ошибки.
<script>
console.log('Requesting data...')
const p = new Promise((resolve, reject) => {
	setTimeout(() => {    //происходит асинхронная операция внутри промиса
		console.log('Preparing data...')
		const backendData = {
			server: 'aws',
			status: 'working'
		}
		resolve(backendData) //выполняет промис и передает дальше данные
	}, 2000)
})

p.then((data) => { //зен запускает коллбэк после выполнения промиса с переданными данными
	return new Promise((resolve, reject) => { //возвращает новый промис из метода зен
		console.log('Modifying data...')
		setTimeout(() => {    //происходит асинхронная операция внутри промиса
			data.modified = true;
			resolve(data) //выполняет промис p_second и передает изменные даные
		}, 2000)
	})

})	
	.then((modifiedData) => { //этот зен уже от вложенного промиса
		console.log('Data received...', modifiedData)
	})
	.catch((err) => {
		console.error('Error: ', err) //в случает reject у прошлого промиса выведет ошибку
	})
	.finally(() => {
		console.log('Finish!') //выполнится в любом случае
	})


//Использование промисов в функциях. Они запускаются одновременно, но заканчивают действие в разное время. Обе функции выполняются асинхронно, т.е. одновременно. С этими функциями можно работать методами промисов, так как они возвращают промис.

const sleep = (ms) => { //функция возвращает промис
	return new Promise (resolve => {
		setTimeout(() => {
			resolve();
		}, ms) //таймер сработает через ms секунд
	})
}

//теперь можно вызывать эти функции и они будут выполняться асинхронно.
sleep(2000).then(() => {
	console.log('after 2 seconds') //работаем методами промиса
})

//еще два важных метода промисов это .all и .race. Они работают с массивами промисов и выполняются либо когда все промисы (или функции, возвращающие промис) выполнены, либо когда хотя бы одна из них (race)
</script>

-------------------------------------------------------------------------------------------------------

throw - приостанавливает выполнение функции и выбрасывает ошибку.

-------------------------------------------------------------------------------------------------------

event.stopPropagation()
Всплытие событий. Если событие привязано к внешнему элементу, то оно сработает и на всех внутренних элементах. Кликнув на Р в примере ниже, сработают все три события. При этом this и event.target будут разными. Всплывают почти все собтыия, за исключением например focus. Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.

this - это элемент, в который было записано событие
event.target - элемент, на который кликнули (в процессе всплытия он остается неизменным)

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>

event.stopPropagation() - не позволит событию всплыть выше по модели ДОМ, чем элемент, который вызывает эту команду.
event.stopImmediatePropagation() - не только не пускает дальше, но и прекращает выполнение событий на текущем элементе.

Погружение событий - перед тем как сработать, событие идет по модели ДОМ до элемента. Чтобы отследить этот момент, необходимо добавлять событие следующей командой.
elem.addEventListener(..., true) - где true - это сокращенная версия {capture: true}. По умолчанию capture имеет значение false, что позволяет перехватывать событие только при всплытии.

-------------------------------------------------------------------------------------------------------
ПЕРЕМЕННЫЕ

let, const - это переменные временные, только для функции или цикла. Вар существует и до объявления(во всем доступном коде), лет существует только после объявления. В целом вар уже не используется. Вар влияет на всю область видимости (либо весь код, либо функция). Лет объявленая в функции видна только в функции(а также внутри внутренних элементов функции). Вар в функции влияет на вар глобально.

var, let и const в циклах. 
Var - видима из любого участка кода. Но опредлена лишь после своего определения. 
Для цикла var одна, она просто меняется для каждой итерации. 

Let живет только в квадратных скобках, в которых была определена. Для каждой итеарции она своя, глобально при этом ее вообще нет. Это легко решает проблему замыкания функций в циклах (в каждом цикле у каждой функции будет своя переменная). С var так не получится, так как в итоге она будет общей для всех итераций. 

Const ведет себя так же как let в цикле.

-------------------------------------------------------------------------------------------------------

function* - это функция-генератор. Она может прерваться во время выполнения и возвратить промежуточный результат, а потом в произвольный момент времени продолжать свое выполнение.

При запуске такой функции самой по себе, ее код не выполняется, вместо этого она возвращает генератор.

Генератор - это объект особого типа. Это замороженный вызов функции.

Основной метод работы с ним это .next(). Он возвращает JSON, где первое поле - значение, второе булеан, который определяет, завершена ли функция. Если функция дошла до конца (последнее значение return), то все следующие запуски будут возвращать значения done: true. Он начинает, либо продолжает выполнение генератора до следующего ключевого слова yield. То есть с ней нужно работать так:
<script>
function* generator () => { //объявление функции
	yield 1;
	yield 2;
	return 3;
}
let generate = generator(); //возвращаем генератор и присваиваем его в переменную

let first = generate.next(); //присвоит first значение JSON, где {value: значение из yield, done: false/true} Иными словами:

console.log(JSON.stringify(first)); // {value: 1, done: false}

</script>

Часто его используют как итератор. 
<script>

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
	alert(value); }
// 1, затем 2, а 3 не выведется, так как циклы не работают с return, вместо этого для корректного отображения нужно указать три поля yield.

</script>

-------------------------------------------------------------------------------------------------------
















