====================================================================================================
<-----------TYPESCRIPT()------------>
====================================================================================================
ВВЕДЕНИЕ В TypeScript

Плюсы TS
/*Может отлавливать ошибки на этапе разработки, до сборки приложения.
Статическая типизация делает код более понятным.
JS тем слабее, чем больше и серьезнее проект. TS приходит на помощь.
Позволяет писать более сложные и крупные JS-приложения, интеграция с IDE
Проще работать в команде
Богатая документация*/

Минусы TS
/*Это дополнительная прослойка, которую нужно внедрять на этапе разработки.*/

/*Файлы расширения ts.
Компиялтор может переводить их в js-файлы при запуске.*/

Типы данных
/*Присовив один раз, потом уже нельзя менять.*/

const isFetching: boolean = true

/*
variable: boolean,
variable: number,
variable: string,
variable: null,
variable: undefined.

variable: number[] - массив из чисел
variable: Array<number> - другая запись того же самого

Tuple - массив из рзных типов данных, записывается как
variable: [string, number]

Any - означает, что переменная будет иметь динамическую типизацию, то есть ей можно 
присваивать любой тип данных.
variable: any
*/

Type
/*Ключевое слово Type нужно для создания собственных типов.
Используется либо для создания одного типа на основе базового(1),
как правило, просто для удобства разработки, 
либо для создания производных типов для таких вещей, как ID, 
который может быть как числом, так и строкой(2)*/

type login = string
const newLogin: login = 'admin' //(1)

type ID = string | number
const newID: ID = 1234
const newID: ID = '1234' //(2)

//Если допустимы неопределенность или null, то

type ID2 = string | number | null | undefined
const newID2: ID2 = null

====================================================================================================

ФУНКЦИИ

/*Не совсем обычная запись. В аргументах указываем их тип данных.
При вызове функции в TS в нее нужно передавать столько аргументов, сколько она содержит.
Чтобы сделать некоторые аргументы необязательными, их помечают знаком ?*/

function sayMyName (name?: string): void { //function declaration, name - необязательный аргумент
	console.log(name)
}

let add = function (a: number, b: number) : number { //function expression
    return a + b;
}

add(1, 2)

//Тип функции void означает, что она ничего не возварщает.
/*Never - тип функции, которая возвращает ошибку или выполняется бесконечно. Например:*/

function throwError (error: string): never {
	throw new Error(error)
}

function infinite (): never {
	while (true){ //бесконечный цикл

	}
}

//Значения параметров по умолчанию задаются следюущим образом:
function getName(firstName: string, lastName: string="Иванов") {
    return firstName + " " + lastName;
}

//Неограниченный набор параметров передается в функцию следующим образом:
function addNumbers(firstNum: number, ...numberArr: number[]): number {
	//some code
}

let result = addNumbers(1, 4, 77, 55, 12) //все аргументы после первого попадут в числовой массив

/*Перегрузка функций в TS.
Так как каждая конкретная функция работает с конкретным типом данных, можно объединять
их под одинаковым именем. Такая функция sum будет складывать строки и числа
в зависимости от того, какие данные получит.*/

function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}

//В более новых версиях используется тип объединения

function myMethod(a: string | number) { //a либо строка либо число.
    //some code
}

====================================================================================================

ИНТЕРФЕЙСЫ

/*Интерфейс это набор свойств и методов, которые объект должен реализовать.
Иными слвоами, это кастомный тип данных. но без реализации.
Они определяются с помощью ключевого слова Interface.*/

interface IUser {
	id: number;
	name: string;
	phone?: number; //необязательный
}

//При реализации интерфейса, создаваемый на его основе объект должен иметь все 
//обязательные поля.

let contact: IUser  = {
	id: 1,
	name: 'Ted'
}

//Другие варианты создания на основе интерфейса
let newObj = {} as IUser
let newObj = <IUser>{}

//Параметры функций (и методов в виде функций) также могут принимать в себя лишь
//объекты или классы, созданные на основе определенного интерфейса.
function getcontact(user: IUser): void {}

//readonly - означает, что свойство только для чтения, нельзя изменить после создания.
interface {readonly x: number;}

//Интерфейсы также могут определять функции, т.е. методы будущих объектов.
//Задается тип принимаемых аргументов и тип выходных данных функции.
//Объект должен будет содержать такую же функцию с таким же параметрами.
interface IUser {
    getFullName(surname: string): string;
}

//Интерфейсы классов
class User implements IUser {...}
//Здесь класс User обязан будет передавть объекту все те же свойства, что и IUser.

//Наследование одного интерфейса другим.
interface IHost extends IUser {
    getAge(): void;
}
//Здесь мы создаем новый интерфейс IHost на основе старого IUser и добавляем в функцию.
//Теперь все объекты, созданные на основе IHost будут должны иметь свойства 
//обоих интерфейсов.

//Интерфейсы бывают: массивов/ Так же такой тип записи подходит для большого
//количества одинаковых свойств.
interface IStringArray {
    [index: number]: string;
}
//интерфейсы функций
interface IFullNameBuilder {
    (name: string, surname: string): string;
}








































