====================================================================================================
<-----------TYPESCRIPT()------------>
====================================================================================================
ВВЕДЕНИЕ В TypeScript

Плюсы TS
/*Может отлавливать ошибки на этапе разработки, до сборки приложения.
Статическая типизация делает код более понятным.
TS нужен только из-за типизации и встроенных анализаторов кода. На нем можно писать,
как на JS, но это лишено всякого смысла. Так что типы задавать обязательно.

JS тем слабее, чем больше и серьезнее проект. TS приходит на помощь.
Позволяет писать более сложные и крупные JS-приложения, интеграция с IDE
Проще работать в команде
Богатая документация*/

Минусы TS
/*Это дополнительная прослойка, которую нужно внедрять на этапе разработки.*/

/*Файлы расширения ts.
Компиялтор может переводить их в js-файлы при запуске.*/

Типы данных
/*Присовив один раз, потом уже нельзя менять.*/

const isFetching: boolean = true

/*
variable: boolean,
variable: number,
variable: string,
variable: null,
variable: undefined.

variable: number[] - массив из чисел
variable: Array<number> - другая запись того же самого

Tuple - массив из рзных типов данных, записывается как
variable: [string, number]

Any - означает, что переменная будет иметь динамическую типизацию, то есть ей можно 
присваивать любой тип данных.
variable: any
*/

------------------------------

Type
/*Ключевое слово Type нужно для создания собственных типов.
Используется либо для создания одного типа на основе базового(1),
как правило, просто для удобства разработки, 
либо для создания производных типов для таких вещей, как ID, 
который может быть как числом, так и строкой(2)*/

type login = string
const newLogin: login = 'admin' //(1)

type ID = string | number
const newID: ID = 1234
const newID: ID = '1234' //(2)

//Если допустимы неопределенность или null, то

type ID2 = string | number | null | undefined
const newID2: ID2 = null

-------------------------------

enum MyEnum {}
/*Перечисление. 
Идеологически это набор связанных друг с другом значений.
Это подвид типа данных число. Это набор значений, пронумерованных как массив.
Исключения составляют элементы. для которых заданы значения.
Значения могут быть как константой, так и могут быть вычисляемыми.
Значения могут быть типа string или number.
Также перечисления могут быть смешанными, т.е. содержать как строки, так и числа.*/
enum Membership {
	Simple, //(0)
	Standart, //(1)
	Premium //(2)
}

const membership = Membership.Standart //равняется 1.
const membershipReverse = Membership[2] //равняется Premium
//Вторая строчка возможна потому, что JS компилирует enum как объект.

//В enum можно сразу задавать или вычислять значение.
enum FileAccess {
	//constants
	None,
	Read = 10, //значение задано сразу
	ReadWrite = Read | Write,
	//calculating elements
	G = '123'.length
}

//Если значение не задано, то компилятор пытается вычислить его автоматически, добавляя 1
//к предыдущему значению.
enum Numbers {
	a, //(0)
	b, //(1)
	c = 0, //(0)
	d //(1)
}
//Есть важный момент в том, что если это смешанное перечисление, то может получиться ошибка,
//если после элемента со строковвм значением указывать элементы,
//значения которых не заданы явно.
//Это лечится заданием числового следующему элементу после строкового.
enum Stones {
  Peach, // 0
  Apricot = "apricot",
  Cherry = 1, // 1, если не задать, полчится error
  Plum // 2
}

//При попытке возвратить строковое значение по номеру, будет показано последнее значение 
//с таким номером.
enum Nuts {
  Peanuts, //0
  Walnut, //1
  Hazelnut = 0, //0
  Cedar //1
}

const nut = Nuts[0] //Hazelnut
const nut2 = Nuts[1] //Cedar


//Внутри перечисления можно создавать ссылки на другие значения - псевдонимы (alias)
//Псевдонимы имеют значения свойства на которое ссылаются.
enum Langues {
  Apple, //value = 0
  Apfel = Apple, //value = 0
  LaPomme = Apple //value = 0
}

====================================================================================================

ФУНКЦИИ

/*Не совсем обычная запись. В аргументах указываем их тип данных.
При вызове функции в TS в нее нужно передавать столько аргументов, сколько она содержит.
Чтобы сделать некоторые аргументы необязательными, их помечают знаком ?*/

function sayMyName (name?: string): void { //function declaration, name - необязательный аргумент
	console.log(name)
}

let add = function (a: number, b: number) : number { //function expression
    return a + b;
}

add(1, 2)

//Тип функции void означает, что она ничего не возварщает.
/*Never - тип функции, которая возвращает ошибку или выполняется бесконечно. Например:*/

function throwError (error: string): never {
	throw new Error(error)
}

function infinite (): never {
	while (true){ //бесконечный цикл

	}
}

//Значения параметров по умолчанию задаются следюущим образом:
function getName(firstName: string, lastName: string="Иванов") {
    return firstName + " " + lastName;
}

//Неограниченный набор параметров передается в функцию следующим образом:
function addNumbers(firstNum: number, ...numberArr: number[]): number {
	//some code
}

let result = addNumbers(1, 4, 77, 55, 12) //все аргументы после первого попадут в числовой массив

/*Перегрузка функций в TS.
Так как каждая конкретная функция работает с конкретным типом данных, можно объединять
их под одинаковым именем. Такая функция sum будет складывать строки и числа
в зависимости от того, какие данные получит.*/

function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}

//В более новых версиях используется тип объединения

function myMethod(a: string | number) { //a либо строка либо число.
    //some code
}

====================================================================================================

ИНТЕРФЕЙСЫ

/*Интерфейс это набор свойств и методов, которые объект должен реализовать.
Иными слвоами, это кастомный тип данных. но без реализации.
Они определяются с помощью ключевого слова Interface.*/

interface IUser {
	id: number;
	name: string;
	phone?: number; //необязательный
}

//При реализации интерфейса, создаваемый на его основе объект должен иметь все 
//обязательные поля.

let contact: IUser  = {
	id: 1,
	name: 'Ted'
}

//Другие варианты создания на основе интерфейса
let newObj = {} as IUser
let newObj = <IUser>{}

//Параметры функций (и методов в виде функций) также могут принимать в себя лишь
//объекты или классы, созданные на основе определенного интерфейса.
function getcontact(user: IUser): void {}

//readonly - означает, что свойство только для чтения, нельзя изменить после создания.
interface {readonly x: number;}

//Интерфейсы также могут определять функции, т.е. методы будущих объектов.
//Задается тип принимаемых аргументов и тип выходных данных функции.
//Объект должен будет содержать такую же функцию с таким же параметрами.
interface IUser {
    getFullName(surname: string): string;
}

//Интерфейсы классов
class User implements IUser {...}
//Здесь класс User обязан будет передавть объекту все те же свойства, что и IUser.

//Наследование одного интерфейса другим.
interface IHost extends IUser {
    getAge(): void;
}
//Здесь мы создаем новый интерфейс IHost на основе старого IUser и добавляем в функцию.
//Теперь все объекты, созданные на основе IHost будут должны иметь свойства 
//обоих интерфейсов.

//Интерфейсы бывают: массивов. Так же такой тип записи подходит для большого
//количества одинаковых свойств.
interface IStringArray {
    [index: number]: string;
}
//интерфейсы функций
interface IFullNameBuilder {
    (name: string, surname: string): string;
}








































