
<----------------КОНСПЕКТЫ ПО JAVASCRIPT()----------------->

=====================================================================================================
КОНЦЕПЦИЯ ООП (BASICS)

//Принципы:

Абстракция 
/*Это отделение концепции от ее экземпляра. 
Это использование только необходимых характеристик объекта, без потери его основных свойств. 
Абстракция данных - это предоставление миру только необходимых данных, и скрытие фоновой информации.*/

Полиморфизм 
/*Это реализация задач одной и той же идеи разными способами. 
Один и тот же код может работать с разными типами данных. 
Обобщенное программирование - код, который можно применять к разным типам данных, 
не меняя его при этом. Есть языки программирования с разными типизациями.
Языки в целом бывают типизированные (Python, C, JS, Java) и нетипизированные (ассемблер)

Типизированные делятся на несколько пересекающихся категорий.
Тип типизации - на статическую типизацию, где конечные типы устанавливаются уже на 
этапе компиляции(C, C#, Java) и динамическую типизацию (JS, Python). 

Сильная/слабая - сильная не позволяет смешивать данные в одной операции, 
например вычитать из строки число (Java, Python) и слабая допускает операции 
с разными данными (C, JS).

Явная или неявная. Явная при объявлении переменной требует указывать ее тип (C++, C#), 
неявная перекладывает задачу определения типа на компилятор (JS, PHP).*/

Наследование
/*Это способность объекта или класса базироваться на другом объекте или классе. 
Это главный механизм для повторного использования кода. Наследственное отношение классов 
четко определяет их иерархию. Принято называть абстрактные прототипы классами.
Базовый класс - объект, находящийся на вершине иерархии.*/

Инкапсуляция 
/*Это размещение одного объекта или класса внутри другого для разграничения доступа к ним. 
Это ограждение какого-либо кода для ограничения доступа к нему и предотвращения его влияния
на другой код.
Пользователю предоставляется лишь интерфейс для взаимодействия с объектом. Сам же объект
он менять не может. К примеру, в JS:*/

function User (name) { //функция-конструктор объекта
    this.name = name;
    var _age = 1; //вместо того, чтобы задавать свойство, мы вводим локальную переменную
    this.displayInfo = function(){
        console.log("Имя: " + this.name + "; возраст: " + _age);
    };
    this.getAge = function() { //это Геттер. Вызвав его, можно получить переменную.
        return _age;
    }
    this.setAge = function(age) { //это сеттер, с помощью его можно менять значение _age
        if(typeof age === "number" && age >0 && age<110){ //вводим условия
            _age = age;
        } else {
            console.log("Недопустимое значение");
        }
    }
}

/*Смысл этого извращения в том, что мы имеем больший контроль над свойством _age.
Мы можем выставлять любые условия для его изменения (setAge).
В этом и есть основной смысл инкапсуляции. */

=====================================================================================================
ОСНОВЫ JS

Типы данных
Переменные
Циклы
Функции
=====================================================================================================
АСИНХРОННОСТЬ

асинхронность в JS
/*JS это однопотчный яп. Однопоточный значит - имеет один стэк вызовов.
Синхронность - означает, что пока выполняется первая строка, вторая не будет выполнена. 
В одну единиц времени может быть выполнено лишь какое-то одно действие.*/

/*Есть данные, которые изначально содержаться в JS в формате кучи (heap). 
При синхронном выполнении JS закидывается в стек, выполняется, достается оттуда 
и только потом туда закидывается следующая строка(команда).
При выполнении функции в функции (например, рекурсия), 
стек вызовов наполняется ими, пока не дойдет до последней вложенной. 
Далее все начинает раскурчиваться обратно. Выполняется самое верхнее действие в стеке. 
Максимальный объем действие в стеке - 16 тысяч. Если лимит превышен - то движок JS V8 очищает его.

Асинхронность - первая строка запускается в фоновом режиме, позволяя второй не дожидаться ее окончания. 
Если бы не было асинхронности, то сайты бы зависали, ожидая выполнения какой-либо команды, 
и не работал бы никакой функционал.

Самый наглядный пример на JS это setTimeout()*/

console.log(1)
setTimeout(() => {
	console.log(2)
}, 2000)
console.log(3)

/*Выведет 1,3,2. setTimeout попадая в стек вызовов, уходит из него невыполненным, уступая место 3. 
А затем возвращается обратно (через 2 секунды) и выполняется. 
Куда ходил таймер? 
Тут вступают в игру Web Api и Event Loop.*/

Event loop
/*Когда setTimeout попадает в очередь запросов, он не выполняется, а перемещается оттуда в Web API. 
Там он ожидает указанное время. В это время стек пустой, и туда попадют другие строки кода. 
По прошествии 2 секунд он должен отправиться в стек. 
Но у Web API нет права закидывать что-либо напрямую в стек, так что он отправит setTimeout 
в очередь задач (Task queue или callback queue). 
Event Loop (цикл событий) добавляет первое событие в списке в стек, когда стек пустой. 
У нас одно событие, так что оно сразу попадет в стек и выполнится. 
Благодаря этому события из Task queue попадают в стек вызовыв по очереди.*/

setTimeout
/*Кстати говоря, setTimeout гарантирует лишь минимальную задержку, так как когда он попадет в 
Event loop, стек вызовов может быть переполнен.*/

Render queue
/*Помимо этого, есть Render queue (обновление экрана, опять же работает лишь когда стек вызовов пустой).
Каждые 16 мс, или 60 раз в секунду, он при наличии пустого стека вызовов обновляет экран. 
Render queue имеет приоритет над Task queue, так что Event loop всегда будет давать им 
просочиться между событиями из Task queue. 
Таким образом, асинхронные действия, приходящие из Task queue, не будут мешать странице обновляться. 
Из этого следует, что все сложные анимации и затратные операции не стоит делать синхронными, 
иначе они будут вызывать фризы экрана.*/

Event listeners
/*События при нажатии кнопки, слушатели событий - все находятся в Web API, 
они попадают туда сразу же при создании подобного события. оттуда они уже попадают в Task queue 
и выполняются при налчии свободного стека вызовов.*/

/*Pyramid of Doom или CallBack Hell - это огромное количество колл-бэков, включенных друг в друга. 
Чтобы такого не было, есть промисы(см. далее).*/

async () и await функции.
/*Это синтаксический сахар для удобства. Можно и на промисах то же самое делать.

Async перед функцией означает, что она вернет промис. 
Промис с результатом, который мы передаем в ретурн. 
Фактически с тем же успехом можно вернуть функцией промис return new Promise. 
Await используется ТОЛЬКО внутри Async (возвращающих промис) функций. 
По факту это эквивалент метода промисов then. 
Он также не мешает коду выполняться дальше, ожидая заврешения промиса. 
Если есть желание использовать await на верхнем уровне вложенности, 
то достаточно просто обернуть ее в анонимную стрелочную async функцию.
Пример:*/

(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();

/*Если промис, которого ждет await закончится с ошибкой (reject), то автоматически 
будет выброшено исключение, как при throw. 
Его можно отлавливать через блок try-catch. 
Блоком try можно охватить неограниченное количество промисов, и все ошибки отловит catch.*/

.then == await promise //это одно и тоже

async function f() {
	let promise = new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('Ready!')
		}, 1000);
	});
	let result = await promise; //ждет выполнения промиса
	console.log(result)	//не выполнится, пока не завершится предыдущая строка
}

f()
console.log('Are you ready?') //выполнится первым, так как функция асинхронна.


/*Обычные итераторы не работают с асинхронными командами. 
Они не будут ждать, когда выполнится функция или промис, так что если нам нужен 
результат предыдущей итерации для рассчета новой, например при использовании forEach, 
то получится ошибка. Для асинхронных операций сработает:*/

for (item of someArray) {
 await foo();
}

//Либо через специальные библиотеки.

--------------------------------

Промисы (Promise)

/*Promises упрощают асинхронность. Собственно внутри него пишется асинхронный код. 
Промис нужен, чтобы соединить создающий и потребляющий участки кода. 
Чтобы не посылать бесконечно запросы, а дождаться выполнения и сразу же запустить другой код, 
который зависит от данных первого. При этом промис не мешает запуститься остальной части кода, 
которая не зависит от него. Также плюс промисов в том, что они могут отлавливать ошибки.
Итак, еще раз, они - просто удобная форма для записи асинхронности. 
Можно создавать цепочку промисов при помощи chaining, просто возваращая в then новый промис.*/

console.log('Requesting data...')
const p = new Promise((resolve, reject) => {
    setTimeout(() => {    //происходит асинхронная операция внутри промиса
        console.log('Preparing data...')
        const backendData = {
            server: 'aws',
            status: 'working'
        }
        resolve(backendData) //выполняет промис и передает дальше данные
    }, 2000)
})

p.then((data) => { //then запускает коллбэк после выполнения промиса с переданными данными
    return new Promise((resolve, reject) => { //возвращает новый промис из метода then
        console.log('Modifying data...')
        setTimeout(() => {    //происходит асинхронная операция внутри промиса
            data.modified = true;
            resolve(data) //передает изменные даные
        }, 2000)
    })

})  
    .then((modifiedData) => { //этот then уже от вложенного промиса
        console.log('Data received...', modifiedData)
    })
    .catch((err) => {
        console.error('Error: ', err) //в случает reject у прошлого промиса выведет ошибку
    })
    .finally(() => {
        console.log('Finish!') //выполнится в любом случае
    })


/*Использование промисов в функциях. Они запускаются одновременно, но заканчивают действие 
в разное время. Обе функции выполняются асинхронно, т.е. одновременно. 
С этими функциями можно работать методами промисов, так как они возвращают промис.*/

const sleep = (ms) => { //функция возвращает промис
    return new Promise (resolve => {
        setTimeout(() => {
            resolve();
        }, ms) //таймер сработает через ms секунд
    })
}

//теперь можно вызывать эти функции и они будут выполняться асинхронно.
sleep(2000).then(() => {
    console.log('after 2 seconds') //работаем методами промиса
})


Методы промисов
/*К ним относятся уже перечисленные выше .then, .catch, .finally
Еще два важных метода промисов это .all и .race. Например:*/

Promise.all([Promise1, Promise2]).then(() => {
    console.log('Это сработает лишь тогда, когда выполнятся и Promise1 и Promise2');
})

/*Они работают с массивами промисов и выполняются либо когда все промисы 
(или функции, возвращающие промис) выполнены, либо когда хотя бы одна из них (race)*/

=====================================================================================================
СОБЫТИЯ, ОБРАБОТКА СОБЫТИЙ
=====================================================================================================





=====================================================================================================
КЛАССЫ
=====================================================================================================
МАССИВЫ И ИХ МЕТОДЫ
=====================================================================================================
ОБЪЕКТЫ И ИХ МЕТОДЫ, this
=====================================================================================================
СЕТЕВЫЕ ЗАПРОСЫ
=====================================================================================================
ПРОТОТИПЫ prototype, __proto__
=====================================================================================================




=====================================================================================================
ПРОЧЕЕ
