----------------------------------------------------------------------------------------------------
АСИНХРОННОСТЬ

JS
/*JS это однопотчный яп. Однопоточный значит - имеет один стэк вызовов.
Синхронность - означает, что пока выполняется первая строка, вторая не будет выполнена. 
В одну единиуц времени может быть выполнено лишь какое-то одно действие.*/

/*Есть данные, которые изначально содержаться в JS в формате кучи (heap). 
При синхронном выполнении JS закидывается в стек, выполняется, достается оттуда 
и только потом туда закидывается следующая строка(команда).
При выполнении функции в функции (например, рекурсия), 
стек вызовов наполняется ими, пока не дойдет до последней вложенной. 
Далее все начинает раскурчиваться обратно. Выполняется самое верхнее действие в стеке. 
Максимальный объем действие в стеке - 16 тысяч. Если лимит превышен - то движок JS V8 очищает его.

Асинхронность - первая строка запускается в фоновом режиме, позволяя второй не дожидаться ее окончания. 
Если бы не было асинхронности, то сайты бы зависали, ожидая выполнения какой-либо команды, 
и не работал бы никакой функционал.

Самый наглядный пример на JS это setTimeout()*/

console.log(1)
setTimeout(() => {
	console.log(2)
}, 2000)
console.log(3)

/*Выведет 1,3,2. setTimeout попадая в стек вызовов, уходит из него невыполненным, уступая место 3. 
А затем возвращается обратно (через 2 секунды) и выполняется. 
Куда ходил таймер? 
Тут вступают в игру Web Api и Event Loop.*/

Event loop
/*Когда setTimeout попадает в очередь запросов, он не выполняется, а перемещается оттуда в Web API. 
Там он ожидает указанное время. В это время стек пустой, и туда попадют другие строки кода. 
По прошествии 2 секунд он должен отправиться в стек. 
Но у Web API нет права закидывать что-либо напрямую в стек, так что он отправит setTimeout 
в очередь задач (Task queue или callback queue). 
Event Loop (цикл событий) добавляет первое событие в списке в стек, когда стек пустой. 
У нас одно событие, так что оно сразу попадет в стек и выполнится. 
Благодаря этому события из Task queue попадают в стек вызовыв по очереди.*/

setTimeout
/*Кстати говоря, setTimeout гарантирует лишь минимальную задержку, так как когда он попадет в 
Event loop, стек вызовов может быть переполнен.*/

Render queue
/*Помимо этого, есть Render queue (обновление экрана, опять же работает лишь когда стек вызовов пустой).
Каждые 16 мс, или 60 раз в секунду, он при наличии пустого стека вызовов обновляет экран. 
Render queue имеет приоритет над Task queue, так что Event loop всегда будет давать им 
просочиться между событиями из Task queue. 
Таким обарзом, асинхронные действия, приходящие из Task queue, не будут мешать странице обновляться. 
Из этого следует, что все сложные анимации и затратные операции не стоит делать синхронными, 
иначе они будут вызывать фризы экрана.*/

Event listeners
/*События при нажатии кнопки, слушатели событий - все находятся в Web API, 
они попадают туда сразу же при создании подобного события. оттуда они уже попадают в Task queue 
и выполняются при налчии свободного стека вызовов.*/

/*Pyramid of Doom или CallBack Hell - это огромное количество колл-бэков, включенных друг в друга. 
Чтобы такого не было, есть промисы(см. далее).*/

async () и await функции.
/*Это синтаксический сахар для удобства. Можно и на промисах то же самое делать.

Async перед функцией означает, что она вернет промис. 
Промис с результатом, который мы передаем в ретурн. 
Фактически с тем же успехом можно вернуть функцией промис return new Promise. 
Await используется ТОЛЬКО внутри Async (возвращающих промис) функций. 
По факту это эквивалент метода промисов then. 
Он также не мешает коду выполняться дальше, ожидая заврешения промиса. 
Если есть желание использовать await на верхнем уровне вложенности, 
то достаточно просто обернуть ее в анонимную стрелочную async функцию.
Пример:*/

(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();

/*Если промис, которого ждет await закончится с ошибкой (reject), то автоматически 
будет выброшено исключение, как при throw. 
Его можно отлавливать через блок try-catch. 
Блоком try можно охватить неограниченное количество промисов, и все ошибки отловит catch.*/

.then == await promise //это одно и тоже

async function f() {
	let promise = new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('Ready!')
		}, 1000);
	});
	let result = await promise; //ждет выполнения промиса
	console.log(result)	//не выполнится, пока не завершится предыдущая строка
}

f()
console.log('Are you ready?') //выполнится первым, так как функция асинхронна.


/*Обычные итераторы не работают с асинхронными командами. 
Они не будут ждать, когда выполнится функция или промис, так что если нам нужен 
результат предыдущей итерации для рассчета новой, например при использовании forEach, 
то получится ошибка. Для асинхронных операций сработает:*/

for (item of someArray) {
 await foo();
}

//Либо через специальные библиотеки.
-----------------------------------------------------------------------------------------------------